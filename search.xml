<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Linux查看系统信息常用命令]]></title>
      <url>http://yoursite.com/2017/02/26/Linux%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h1 id="Linux查看系统信息常用命令"><a href="#Linux查看系统信息常用命令" class="headerlink" title="Linux查看系统信息常用命令"></a>Linux查看系统信息常用命令</h1><h2 id="查看版本信息"><a href="#查看版本信息" class="headerlink" title="查看版本信息"></a>查看版本信息</h2><ol>
<li>输入<code>uname -a</code>,可显示电脑以及操作系统的相关信息。     <img src="/2017/02/26/Linux查看系统信息常用命令/1.png" alt="1.png" title=""></li>
<li>输入<code>cat /proc/version</code>,说明正在运行的内核版本。<img src="/2017/02/26/Linux查看系统信息常用命令/2.png" alt="2.png" title=""></li>
<li>输入<code>cat /etc/issue</code>, 显示的是发行版本信息<img src="/2017/02/26/Linux查看系统信息常用命令/3.png" alt="3.png" title=""></li>
<li><code>lsb_release -a</code><br>(适用于所有的linux，包括Redhat、SuSE、Debian等发行版，但是在debian下要安装lsb)<img src="/2017/02/26/Linux查看系统信息常用命令/4.png" alt="4.png" title="">
<a id="more"></a>
<h2 id="查看物理CPU个数、核数、逻辑CPU个数"><a href="#查看物理CPU个数、核数、逻辑CPU个数" class="headerlink" title="查看物理CPU个数、核数、逻辑CPU个数"></a>查看物理CPU个数、核数、逻辑CPU个数</h2></li>
</ol>
<p>总核数 = 物理CPU个数 X 每颗物理CPU的核数<br>总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数</p>
<ol>
<li>查看物理CPU个数<br><code>cat /proc/cpuinfo| grep &quot;physical id&quot;| sort| uniq| wc -l</code></li>
<li>查看每个物理CPU中core的个数(即核数)<br><code>cat /proc/cpuinfo| grep &quot;cpu cores&quot;| uniq</code></li>
<li>查看逻辑CPU的个数<br><code>cat /proc/cpuinfo| grep &quot;processor&quot;| wc -l</code></li>
<li>查看CPU信息（型号）<br><code>cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</code></li>
</ol>
<h2 id="查看系统内存"><a href="#查看系统内存" class="headerlink" title="查看系统内存"></a>查看系统内存</h2><p>使用命令<code>free</code>来查看系统的总内存和内存使用情况。<br><img src="/2017/02/26/Linux查看系统信息常用命令/5.png" alt="5.png" title=""></p>
<p>上图中，total那一列第一行数据即为系统总内存：1004608（KB）。<br>used列第一行数据即为系统已使用内存：760136（KB）。<br>free列第一行数据即为系统还可以用的内存：244472（KB）。</p>
<p>想要了解其他行列的含义可以参考<a href="http://www.cnblogs.com/coldplayerest/archive/2010/02/20/1669949.html" target="_blank" rel="external">这里</a></p>
<h2 id="实时查看进程占用资源情况"><a href="#实时查看进程占用资源情况" class="headerlink" title="实时查看进程占用资源情况"></a>实时查看进程占用资源情况</h2><p><code>top</code>命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。<br><img src="/2017/02/26/Linux查看系统信息常用命令/6.png" alt="6.png" title=""></p>
<p>如上图所示，top命令的前五行信息为统计信息</p>
<ol>
<li><p>第一行是任务队列信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">18:58:35    当前时间</div><div class="line">up 26 min    系统运行时间</div><div class="line">2 user    当前登录用户数</div><div class="line">load average: 0.00, 0.00, 0.00    系统负载，即任务队列的平均长度。三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。</div></pre></td></tr></table></figure>
</li>
<li><p>第二行是进程信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">total 进程总数</div><div class="line">running 正在运行的进程数</div><div class="line">sleeping 睡眠的进程数</div><div class="line">stopped 停止的进程数</div><div class="line">zombie 僵尸进程数</div></pre></td></tr></table></figure>
</li>
<li><p>第三行是CPU信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">0.3% us 用户空间占用CPU百分比</div><div class="line">0.0% sy 内核空间占用CPU百分比</div><div class="line">0.0% ni 用户进程空间内改变过优先级的进程占用CPU百分比</div><div class="line">99.3% id 空闲CPU百分比</div><div class="line">0.0% wa 等待输入输出的CPU时间百分比</div><div class="line">0.0%hi：硬件CPU中断占用百分比</div><div class="line">0.3%si：软中断占用百分比</div><div class="line">0.0%st：虚拟机占用百分比</div></pre></td></tr></table></figure>
</li>
<li><p>第四、五行是内存信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Mem:</div><div class="line">1004608k total    物理内存总量</div><div class="line">760548k used    使用的物理内存总量</div><div class="line">244060k free    空闲内存总量</div><div class="line">13656k buffers    用作内核缓存的内存量</div><div class="line">Swap: </div><div class="line">1023992k total    交换区总量</div><div class="line">0k used    使用的交换区总量</div><div class="line">1023992k free    空闲交换区总量</div><div class="line">108492k cached    缓冲的交换区总量,内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖，该数值即为这些内容已存在于内存中的交换区的大小,相应的内存再次被换出时可不必再对交换区写入</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="http://www.cnblogs.com/coldplayerest/archive/2010/02/20/1669949.html" target="_blank" rel="external">http://www.cnblogs.com/coldplayerest/archive/2010/02/20/1669949.html</a></p>
<p><a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316399.html" target="_blank" rel="external">http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316399.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[nignx 负载均衡配置]]></title>
      <url>http://yoursite.com/2017/02/15/nginx-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h1 id="nignx-负载均衡配置"><a href="#nignx-负载均衡配置" class="headerlink" title="nignx 负载均衡配置"></a>nignx 负载均衡配置</h1><p>Nginx常用负载均衡算法：</p>
<ol>
<li>轮询（默认算法）——每个请求会依次分配给后端不同的应用程序服务器，不理会后端服务器的实际压力</li>
<li>加权轮询——权重越大的服务器，被分配到的次数就会越多，通常用于后端服务器性能不一致的情况</li>
<li>IP HASH——当同IP进行重复访问时会被指定到上次访问到的服务器，可以解决动态网站SESSION共享问题<a id="more"></a>
</li>
</ol>
<p>upstream模块常用参数说明：<br><img src="/2017/02/15/nginx-负载均衡配置/1.jpg" alt="1.jpg" title=""></p>
<h2 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h2><p>本次试验采用nginx版本为:nginx-1.9.5</p>
<p>本文实验采用同一个IP，不同端口来模拟负载均衡，分别在三个文件夹下下放入不同的三张图片，<strong>图片的名称相同</strong>,在这个三个文件夹下使用<code>http-server</code>命令开启服务器，分别指定端口为8881,8882,8883。其中8881,8882,8883对应的图片如下图顺序所示：<br><img src="/2017/02/15/nginx-负载均衡配置/8881.jpg" alt="8881.jpg" title=""><br><img src="/2017/02/15/nginx-负载均衡配置/8882.jpg" alt="8882.jpg" title=""><br><img src="/2017/02/15/nginx-负载均衡配置/8883.jpg" alt="8883.jpg" title=""></p>
<h2 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">http &#123;        #upstream模块包含在http模块下</div><div class="line">    upstream load_balancing_default  &#123;  #定义upstream名字，下面会引用</div><div class="line">		server 10.10.60.82:8881;  #服务器地址</div><div class="line">		server 10.10.60.82:8882;</div><div class="line">		server 10.10.60.82:8883;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen       8866;#端口号</div><div class="line">        server_name  localhost;#当前服务的域名</div><div class="line">        location /default &#123;</div><div class="line">           proxy_pass  http://load_balancing_default/;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的配置中，当用户访问<code>http://localhost:8866/default/logo.jpg</code>地址时，Nginx会负载平衡分配给后端的三个服务器。我么可以不断刷新，通过显示图片的不同证明请求被发送到不同的服务器地址上。</p>
<img src="/2017/02/15/nginx-负载均衡配置/2.gif" alt="2.gif" title="">
<h2 id="加权负载均衡"><a href="#加权负载均衡" class="headerlink" title="加权负载均衡"></a>加权负载均衡</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">	upstream load_balancing_weight  &#123;</div><div class="line">		server 10.10.60.82:8881;</div><div class="line">		server 10.10.60.82:8882 weight=2;  #指定服务器地址，权重为2</div><div class="line">		server 10.10.60.82:8883;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen       8866;#端口号</div><div class="line">        server_name  localhost;#当前服务的域名</div><div class="line">        location /weight &#123;</div><div class="line">           proxy_pass  http://load_balancing_weight/;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的配置中，当用户访问<code>http://localhost:8866/weight/logo.jpg</code>地址时，每四个请求为一组，前两个请求分配给10.10.60.82:8882，然后第3，4个请求会分配给110.10.60.82:8881和10.10.60.82:8883，如此循环下去。</p>
<img src="/2017/02/15/nginx-负载均衡配置/3.gif" alt="3.gif" title="">
<h2 id="IP-HASH负载均衡"><a href="#IP-HASH负载均衡" class="headerlink" title="IP HASH负载均衡"></a>IP HASH负载均衡</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">	upstream load_balancing_ip  &#123;</div><div class="line">		ip_hash;        #采用IP HASH算法</div><div class="line">		server 10.10.60.82:8881;</div><div class="line">		server 10.10.60.82:8882;</div><div class="line">		server 10.10.60.82:8883;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen       8866;#端口号</div><div class="line">        server_name  localhost;#当前服务的域名</div><div class="line">        location /ip_hash &#123;</div><div class="line">           proxy_pass  http://load_balancing_ip/;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果需要将客户与后端一台服务器“绑定”起来，可以使用ip-hash负载平衡机制。这样可以确保来自相同客户机的请求总是指向相同的服务器除非该服务器不可用。</p>
<p>在上面的配置中，当用户访问<code>http://localhost:8866/ip_hash/logo.jpg</code>地址时，同一个ip访问到的图片是同一张，证明，同一个ip的客户访问的服务器是同一个。</p>
<img src="/2017/02/15/nginx-负载均衡配置/4.gif" alt="4.gif" title="">
<h2 id="nginx-高可用"><a href="#nginx-高可用" class="headerlink" title="nginx 高可用"></a>nginx 高可用</h2><p>Nginx高可用的实现，利用backup标签，可以实现高可用，当主服务挂掉后，backup服务器会自动接管服务，当主服务恢复后，backup也会自动放弃服务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">	upstream high_availability  &#123;</div><div class="line">		server 10.10.60.82:8881;</div><div class="line">		server 10.10.60.82:8882 backup;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen       8866;#端口号</div><div class="line">        server_name  localhost;#当前服务的域名</div><div class="line">        location /h_a &#123;</div><div class="line">           proxy_pass  http://high_availability/;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的配置中，当用户访问<code>http://localhost:8866/h_a/logo.jpg</code>地址时，访问到的图片是一直是8881端口内的图片名，当我把8881这个端口对应的服务<strong>停止</strong>之后，再次访问该路径，该请求一直在等待，直到<strong>一分钟</strong>之后,backup对应的机器，也就是8882端口对应的图片显示出来。</p>
<img src="/2017/02/15/nginx-负载均衡配置/5.jpg" alt="5.jpg" title="">
<p>起初我认为该请求首先由8881端口的服务器进行处理，但是该服务已经停止，所以尝试失败之后，在此常识请求backup对应的服务器，拿到图片。<br>那么我认为这个时间和<code>max_fails</code>（最大失败次数）,<code>fail_timeout</code>（失败超时时间）两个参数的值有关，实际的等待时间为两者之积，然后我将配置改成如下，增加了这两个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">	upstream high_availability  &#123;</div><div class="line">		server 10.10.60.82:8881 max_fails=2 fail_timeout=2s ;</div><div class="line">		server 10.10.60.82:8882 backup;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen       8866;#端口号</div><div class="line">        server_name  localhost;#当前服务的域名</div><div class="line">        location /h_a &#123;</div><div class="line">           proxy_pass  http://high_availability/;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>再次运行的结果与原来相同</strong>，仍是等待一分钟之后拿到backup对应服务器下的图片，不知道为什么。</p>
<p><strong>上述问题已找到解决方案，在http模块下增加<code>proxy_connect_timeout 3;</code> 这个配置，每个服务器的链接超时时间为3秒。配置如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">	proxy_connect_timeout 3;</div><div class="line"></div><div class="line">	upstream high_availability  &#123;</div><div class="line">		server 10.10.60.82:8881 max_fails=2 fail_timeout=2s ;</div><div class="line">		server 10.10.60.82:8882 backup;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen       8866;#端口号</div><div class="line">        server_name  localhost;#当前服务的域名</div><div class="line">        location /h_a &#123;</div><div class="line">           proxy_pass  http://high_availability/;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>max_fails</code> 和 <code>fail_timeout</code> 参数的意思是在某服务器失败次数达到<code>max_fails</code> 次时，那么判定该机器在 <code>fail_timeout</code> 时间内不可用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时)</div><div class="line">proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时)</div><div class="line">proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时)</div></pre></td></tr></table></figure>
<h2 id="配置文件下载地址"><a href="#配置文件下载地址" class="headerlink" title="配置文件下载地址"></a>配置文件下载地址</h2><p><a href="https://github.com/gengdn/nginx_load_balancing.git" target="_blank" rel="external">https://github.com/gengdn/nginx_load_balancing.git</a></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p> <a href="http://nginx.org/en/docs/" target="_blank" rel="external">Nginx官方文档</a><br> <a href="http://www.linuxidc.com/Linux/2016-04/130350.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2016-04/130350.htm</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux nfs 挂载]]></title>
      <url>http://yoursite.com/2017/02/10/Linux-nfs%E6%8C%82%E8%BD%BD/</url>
      <content type="html"><![CDATA[<h2 id="文件服务器"><a href="#文件服务器" class="headerlink" title="文件服务器"></a>文件服务器</h2><h3 id="检查-rpcbind-和-nfs服务是否安装"><a href="#检查-rpcbind-和-nfs服务是否安装" class="headerlink" title="检查 rpcbind  和 nfs服务是否安装"></a>检查 rpcbind  和 nfs服务是否安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rpm -qa | grep rpcbind</div><div class="line">rpm -qa | grep nfs</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="修改文件服务器的-etc-exports-文件"><a href="#修改文件服务器的-etc-exports-文件" class="headerlink" title="修改文件服务器的 /etc/exports 文件"></a>修改文件服务器的 /etc/exports 文件</h3><p>确保上述两个服务安装之后  修改文件服务器的 /etc/exports 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/exports</div></pre></td></tr></table></figure></p>
<p>加入内容格式：&lt;输出目录&gt; [客户端1 选项（访问权限,用户映射,其他）] [客户端2 选项（访问权限,用户映射,其他）]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eg：/bingoLink/elearning 172.133.1.0/24(rw,async,no_root_squash,no_subtree_check)</div></pre></td></tr></table></figure></p>
<ol>
<li><p>输出目录:<br>/bingoLink/elearning 为本机要共享的文件夹</p>
</li>
<li><p>客户端:<br>172.133.1.0/24为可以访问这个共享的计算机<br>–客户端常用的指定方式<br>指定ip地址的主机：192.168.0.200<br>指定子网中的所有主机：192.168.0.0/24 192.168.0.0/255.255.255.0<br>指定域名的主机：david.bsmart.cn<br>指定域中的所有主机：<em>.bsmart.cn<br>所有主机：</em></p>
</li>
<li><p>选项：<br>选项用来设置输出目录的访问权限、用户映射等。</p>
</li>
</ol>
<p>NFS主要有3类选项：</p>
<p>访问权限选项</p>
<p>设置输出目录只读：ro<br>设置输出目录读写：rw<br>用户映射选项</p>
<p>all_squash：将远程访问的所有普通用户及所属组都映射为匿名用户或用户组（nfsnobody）；<br>no_all_squash：与all_squash取反（默认设置）；<br>root_squash：将root用户及所属组都映射为匿名用户或用户组（默认设置）；<br>no_root_squash：与rootsquash取反；<br>anonuid=xxx：将远程访问的所有用户都映射为匿名用户，并指定该用户为本地用户（UID=xxx）；<br>anongid=xxx：将远程访问的所有用户组都映射为匿名用户组账户，并指定该匿名用户组账户为本地用户组账户（GID=xxx）；<br>其它选项</p>
<p>secure：限制客户端只能从小于1024的tcp/ip端口连接nfs服务器（默认设置）；<br>insecure：允许客户端从大于1024的tcp/ip端口连接服务器；<br>sync：将数据同步写入内存缓冲区与磁盘中，效率低，但可以保证数据的一致性；<br>async：将数据先保存在内存缓冲区中，必要时才写入磁盘；<br>wdelay：检查是否有相关的写操作，如果有则将这些写操作一起执行，这样可以提高效率（默认设置）；<br>no_wdelay：若有写操作则立即执行，应与sync配合使用；<br>subtree：若输出目录是一个子目录，则nfs服务器将检查其父目录的权限(默认设置)；<br>no_subtree：即使输出目录是一个子目录，nfs服务器也不检查其父目录的权限，这样可以提高效率；</p>
<h3 id="修改完成后启动nfs服务"><a href="#修改完成后启动nfs服务" class="headerlink" title="修改完成后启动nfs服务"></a>修改完成后启动nfs服务</h3><p>为了使NFS服务器能正常工作，需要启动rpcbind和nfs两个服务，并且rpcbind一定要先于nfs启动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># service rpcbind start</div><div class="line"># service nfs start</div></pre></td></tr></table></figure></p>
<p>查询NFS服务器状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># service rpcbind status</div><div class="line"># service nfs status</div></pre></td></tr></table></figure></p>
<p>停止NFS服务器</p>
<p>要停止NFS运行时，需要先停止nfs服务再停止rpcbind 服务，对于系统中有其他服务(如NIS)需要使用时，不需要停止rpcbind 服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># service nfs stop</div><div class="line"># service rpcbind stop</div></pre></td></tr></table></figure></p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>服务器端使用showmount命令查询NFS的共享状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># showmount -e　　　　//默认查看自己共享的服务，前提是要DNS能解析自己，不然容易报错</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># showmount -a　　　　//显示已经与客户端连接上的目录信息</div></pre></td></tr></table></figure>
<p>客户端使用showmount命令查询NFS的共享状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># showmount -e NFS服务器IP</div><div class="line">eg：showmount -e 172.133.41.171</div></pre></td></tr></table></figure></p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://www.cnblogs.com/mchina/archive/2013/01/03/2840040.html" target="_blank" rel="external">http://www.cnblogs.com/mchina/archive/2013/01/03/2840040.html</a></p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="修改-etc-fstab文件"><a href="#修改-etc-fstab文件" class="headerlink" title="修改 /etc/fstab文件"></a>修改 /etc/fstab文件</h3><p>增加如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">172.20.114.155:/home/bingo/link/go /home/bingo/link/soft/package/webapp/go nfs  auto,nolock,intr,timeo=5,retrans=5,actimeo=10,retry=5,rsize=1048576,wsize=1048576,noatime,nodiratime,async 0       0</div></pre></td></tr></table></figure></p>
<p>修改完成后重启生效，如果不想重启，可以先使用mount命令挂载上，等待重启后自动生效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mount -t nfs 172.20.114.155:/home/bingo/link/go /home/bingo/link/soft</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 小记]]></title>
      <url>http://yoursite.com/2017/02/09/Linux%E5%B0%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="给tomcat指定启动时使用的jdk"><a href="#给tomcat指定启动时使用的jdk" class="headerlink" title="给tomcat指定启动时使用的jdk"></a>给tomcat指定启动时使用的jdk</h2><p>修改tomcat中bin目录下的 setclasspath.sh 文件<br>在顶部的空白处增加如下内容:<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export JAVA_HOME=/bingo/bingoscreen/srv/jdk1.7.0_79</div><div class="line">export JRE_HOME=$JAVA_HOME/jre</div></pre></td></tr></table></figure></p>
<h2 id="查看tomcat使用的jdk版本"><a href="#查看tomcat使用的jdk版本" class="headerlink" title="查看tomcat使用的jdk版本"></a>查看tomcat使用的jdk版本</h2><p>进入tomcat的bin目录下 执行 ./version.sh</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[root@i-52593751 bin]# ./version.sh </div><div class="line">Using CATALINA_BASE:   /bingo/bingoscreen/srv/apache-tomcat-7.0.65</div><div class="line">Using CATALINA_HOME:   /bingo/bingoscreen/srv/apache-tomcat-7.0.65</div><div class="line">Using CATALINA_TMPDIR: /bingo/bingoscreen/srv/apache-tomcat-7.0.65/temp</div><div class="line">Using JRE_HOME:        /bingo/bingoscreen/srv/jdk1.7.0_79/jre</div><div class="line">Using CLASSPATH:       /bingo/bingoscreen/srv/apache-tomcat-7.0.65/bin/bootstrap.jar:/bingo/bingoscreen/srv/apache-tomcat-7.0.65/bin/tomcat-juli.jar</div><div class="line">Server version: Apache Tomcat/7.0.65</div><div class="line">Server built:   Oct 9 2015 08:36:58 UTC</div><div class="line">Server number:  7.0.65.0</div><div class="line">OS Name:        Linux</div><div class="line">OS Version:     2.6.32-573.7.1.el6.x86_64</div><div class="line">Architecture:   amd64</div><div class="line">JVM Version:    1.7.0_79-b15</div><div class="line">JVM Vendor:     Oracle Corporation</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Jvm_3_垃圾收集算法]]></title>
      <url>http://yoursite.com/2016/12/26/Jvm_3_%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>最基础的收集算法是“标记-清除”（Mark-Sweep）算法，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。<br><a id="more"></a></p>
<p>之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。它的不足主要有两个：<strong>一个是效率问题</strong>，标记和清除两个过程效率都不高；另一个是<strong>空间问题</strong>，标记清除之后产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</p>
<img src="/2016/12/26/Jvm_3_垃圾收集算法/1.jpg" alt="1.jpg" title="">
<h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p><strong>为了解决效率问题</strong>，一种称为“复制”（copying）的算法出现了，<strong>它将可用内存按容量划分为大小相等的两块</strong>，每次只使用其中的一块，当着一块内存用完了，<strong>将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉</strong>。这样使得每次都是对整个半区进行内存回收，内存分配时也不用考虑内存碎片等复杂情况。只是这种算法的代价是将<strong>内存缩小为原来的一半</strong>，未免太高了一些。</p>
<img src="/2016/12/26/Jvm_3_垃圾收集算法/2.jpg" alt="2.jpg" title="">
<h2 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h2><p>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是<strong>让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存</strong>。</p>
<img src="/2016/12/26/Jvm_3_垃圾收集算法/3.jpg" alt="3.jpg" title="">
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>这种算法并没有什么新的思想，只是根据对象存活周期的不痛将内存划分为几块，一般是<strong>把Java堆分为新生代和老年代</strong>，这样就可以根据各个年代的特点采用最适当的算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用<strong>复制算法</strong>。而老年代中<strong>因为对象存活率高、没有额外空间对它进行分配担保，</strong>就必须使用<strong>“标记-清理”</strong>或者<strong>“标记-整理”</strong>算法来进行回收。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Jvm_2_垃圾收集器与内存分类策略]]></title>
      <url>http://yoursite.com/2016/12/21/Jvm_2_%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E7%B1%BB%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<h1 id="垃圾收集器与内存分类策略"><a href="#垃圾收集器与内存分类策略" class="headerlink" title="垃圾收集器与内存分类策略"></a>垃圾收集器与内存分类策略</h1><p>　　回想Java内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；每一个栈帧中分配多少内存基本上在类结构确定下来时就是已知的，因此这几个区域的内存分配和回收都具备确定性，在这个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存就跟随着回收了。<br>　　而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间才能够知道创建哪些对象，这部分的内存分配和回收都是动态的，垃圾收集器所关注的就是这部分内存。<br><a id="more"></a></p>
<h2 id="对象已死吗？"><a href="#对象已死吗？" class="headerlink" title="对象已死吗？"></a>对象已死吗？</h2><p>　　垃圾收集器在对堆进行回收前，第一件事就是要确定这些对象之中哪些还“活着”，哪些已经“死去”。
　　</p>
<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>　　很多教科书判断对象是否活着的算法是这样的：给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用时效时，计数器值就减1.任何时刻，计数器为0的对象就是不可能再被使用的。<br>　　<br>　　在主流的Java虚拟机里没有选用引用计数算法来管理内存，其中最主要的原因是<strong>它很难解决对象之间相互循环引用的问题</strong><br>　　<br>　　举个简单的例子，下面的代码中，objA和objB都有字段instance，赋值令objA.instance = objB及 objB.instance = objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不能在被访问，但是他们相互引用着对方，导致他们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们。<br>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * testGC()方法执行后，objA和objB会不会被GC呢？ </div><div class="line"> */</div><div class="line">public class ReferenceCountingGC &#123;</div><div class="line"></div><div class="line">	public Object instance = null;</div><div class="line"></div><div class="line">	private static final int _1MB = 1024 * 1024;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 这个成员属性的唯一意义就是占点内存，以便在能在GC日志中看清楚是否有回收过</div><div class="line">	 */</div><div class="line">	private byte[] bigSize = new byte[2 * _1MB];</div><div class="line"></div><div class="line">	public static void testGC() &#123;</div><div class="line">		ReferenceCountingGC objA = new ReferenceCountingGC();</div><div class="line">		ReferenceCountingGC objB = new ReferenceCountingGC();</div><div class="line">		objA.instance = objB;</div><div class="line">		objB.instance = objA;</div><div class="line"></div><div class="line">		objA = null;</div><div class="line">		objB = null;</div><div class="line"></div><div class="line">		// 假设在这行发生GC，objA和objB是否能被回收？</div><div class="line">		System.gc();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>该算法的基本思想就是通过一系列的成为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有引用链项链时，则证明此对象是不可用的。</p>
<p>在Java语言中，可作为GC Roots的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法去中常量引用的对象。</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li>
</ul>
<h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>在JDK1.2之前，Java中的引用的定义很传统，如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。<br>在JDK1.2之后，java对引用的概念进行了扩充，将引用分为<strong>强引用</strong>、<strong>软引用</strong>、<strong>弱引用</strong>、<strong>虚引用</strong>四种，这四种引用的强度依次逐渐减弱。</p>
<ul>
<li>强引用就是指在程序代码中普片存在的，类似”<code>Object obj = new Object()</code>“ 这类的引用，只要强引用还存在，垃圾收集器<strong>永远不会回收掉</strong>被引用的对象。</li>
<li>软引用是用来描述一些还有用但并非必须的对象，对于软引用关联着的对象，在系统将要发生<strong>内存溢出异常之前</strong>，将会把这些对象列进回收范围之中进行第<strong>二次回收</strong>。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了<strong>SoftReference</strong>类来实现软引用</li>
<li>弱引用也是用来描述非必须对象的。但是它的强度<strong>比软引用更弱一些</strong>。被弱引用关联的对象<strong>只能生存到下一次垃圾收集发生之前</strong>。当垃圾收集器工作时，<strong>无论当前内存是否足够，都会回收掉只被弱引用关联的对象</strong>。在JDK1.2之后，提供了<strong>WeakReference</strong>类来实现弱引用。</li>
<li>虚引用也成为幽灵引用或者幻影引用，它是<strong>最弱</strong>的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也<strong>无法通过虚引用来取得一个对象实例</strong>。为一个对象设置虚引用关联的<strong>唯一目的就是能在这个对象被收集器回收时收到一个系统通知</strong>。在JDK1.2之后，提供了PhantomReference类来实现虚引用。</li>
</ul>
<h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><p>及时在可达性分析算法中不可达的对象，也并非是“非死不可的”，这时候他们暂时处于“缓刑”阶段，真正宣告一个对象的死亡，至少要经历<strong>两次</strong>标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，<strong>筛选的条件是此对象是否有必要执行<code>finalize()</code>方法。</strong>当对象<strong>没有覆盖<code>finalize()</code>方法</strong>或者<strong><code>finalize()</code>方法已经被虚拟机调用过</strong>，虚拟机将这两种情况都视为“没有必要执行”。</p>
<p>如果对象被判定为有必要执行<code>finalize()</code>方法，那么这个对象将会被放置在一个叫做F-Queue的队列中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的执行是指虚拟机会触发这个方法，但<strong>并不承诺会等待它运行结束</strong>，原因是防止<code>finalize()</code>方法执行缓慢甚至发生死循环，将可能导致整个内存回收系统崩溃。<strong><code>finalize()</code>方法是对象逃脱死亡的最后一次机会</strong>，稍后<strong>GC将对F-Queue中的对象进行第二次小规模的标记</strong>，如果对象在<code>finalize()</code>方法中成功拯救自己————只要重新与引用链上的任何一个对象关联即可，那在第二次标记时它将被溢出“即将回收”的集合。</p>
<p>如下代码展示了一个对象的<code>finalize()</code>被执行，但是它仍然可以存活。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 此代码演示了两点： </div><div class="line"> * 1.对象可以在被GC时自我拯救。 </div><div class="line"> * 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</div><div class="line"> */</div><div class="line">public class FinalizeEscapeGC &#123;</div><div class="line"></div><div class="line">	public static FinalizeEscapeGC SAVE_HOOK = null;</div><div class="line"></div><div class="line">	public void isAlive() &#123;</div><div class="line">		System.out.println(&quot;yes, i am still alive :)&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void finalize() throws Throwable &#123;</div><div class="line">		super.finalize();</div><div class="line">		System.out.println(&quot;finalize mehtod executed!&quot;);</div><div class="line">		FinalizeEscapeGC.SAVE_HOOK = this;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) throws Throwable &#123;</div><div class="line">		SAVE_HOOK = new FinalizeEscapeGC();</div><div class="line"></div><div class="line">		//对象第一次成功拯救自己</div><div class="line">		SAVE_HOOK = null;</div><div class="line">		System.gc();</div><div class="line">		// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</div><div class="line">		Thread.sleep(500);</div><div class="line">		if (SAVE_HOOK != null) &#123;</div><div class="line">			SAVE_HOOK.isAlive();</div><div class="line">		&#125; else &#123;</div><div class="line">			System.out.println(&quot;no, i am dead :(&quot;);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// 下面这段代码与上面的完全相同，但是这次自救却失败了</div><div class="line">		SAVE_HOOK = null;</div><div class="line">		System.gc();</div><div class="line">		// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</div><div class="line">		Thread.sleep(500);</div><div class="line">		if (SAVE_HOOK != null) &#123;</div><div class="line">			SAVE_HOOK.isAlive();</div><div class="line">		&#125; else &#123;</div><div class="line">			System.out.println(&quot;no, i am dead :(&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br>finalize mehtod executed!<br>yes, i am still alive :)<br>no, i am dead :(</p>
<p>从运行结果可以看出，SAVE_HOOK 对象的<code>finalize()</code>方法确实被GC收集器触发过，并且被在收集前成功逃脱了。</p>
<p>值得注意的是，代码中有两段完全一样的代码片段，执行结果却是第一次逃脱成功，第二次逃脱失败，这是因为<strong>对象的<code>finalize()</code>方法都只会被系统自动调用一次</strong>。</p>
<p>需要特别说明的是，<code>finalize()</code>能做的所有工作，使用try-finally或者其他方式都可以做的更好、更及时。所以不建议使用这个方法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux下scp命令跳过登陆验证]]></title>
      <url>http://yoursite.com/2016/12/18/Linux%E4%B8%8Bscp%E5%91%BD%E4%BB%A4%E8%B7%B3%E8%BF%87%E7%99%BB%E9%99%86%E9%AA%8C%E8%AF%81/</url>
      <content type="html"><![CDATA[<h1 id="Linux下执行scp命令时跳过登陆验证"><a href="#Linux下执行scp命令时跳过登陆验证" class="headerlink" title="Linux下执行scp命令时跳过登陆验证"></a>Linux下执行scp命令时跳过登陆验证</h1><h2 id="生成安全信任关系证书"><a href="#生成安全信任关系证书" class="headerlink" title="生成安全信任关系证书"></a>生成安全信任关系证书</h2><p>1.在要执行scp命令的机器上 root 用户执行 <code>ssh-keygen</code> 命令，生成建立安全信任关系的证书。<br>[root@Client root]# ssh-keygen<br>Generating public/private rsa key pair.<br>Enter file in which to save the key (/root/.ssh/id_rsa):<br>Enter passphrase (empty for no passphrase):            &lt;– 直接输入回车<br>Enter same passphrase again:                           &lt;– 直接输入回车<br>Your identification has been saved in /root/.ssh/id_rsa.<br>Your public key has been saved in /root/.ssh/id_rsa.pub.<br>The key fingerprint is:<br>49:9c:8a:8f:bc:19:5e:8c:c0:10:d3:15:60:a3:32:1c root@Client<br>[root@Client root]#<br><a id="more"></a></p>
<p>注意：在程序提示输入passphrase时直接输入回车，表示无证书密码。<br>上述命令将生成私钥证书id_rsa和公钥证书id_rsa.pub，存放在用户家目录的.ssh子目录中。</p>
<h2 id="复制公钥证书"><a href="#复制公钥证书" class="headerlink" title="复制公钥证书"></a>复制公钥证书</h2><p>将公钥证书id_rsa.pub复制到机器Server的root家目录的.ssh子目录中（无此目录需要创建），同时将文件名更换为authorized_keys。</p>
<p>[root@Client root]# scp -p .ssh/id_rsa.pub root@192.168.3.206:/root/.ssh/authorized_keys<br>root@192.168.3.206’s password:          &lt;– 输入机器Server的root用户密码<br>id_rsa.pub           100% |<strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong>|   218       00:00<br>[root@Client root]#</p>
<h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><p>执行 ssh-copy-id root@10.10.60.119</p>
<p>如果不成功<br>修改./ssh 文件夹的权限为700<br>修改authorized_keys 文件的权限为600</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Jvm_1_内存区域与内存溢出异常]]></title>
      <url>http://yoursite.com/2016/12/16/Jvm_1_%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
      <content type="html"><![CDATA[<p>　　了解和思考Java技术体系中这些技术特性是如何实现的，认识这些技术运作的本质，是自己思考“程序这样写好比好”的基础和前提。当我们在使用一种技术时，如果不在依赖于书本和他人就能得到这些问题的答案，那才算上升到了“不惑”的境界。<br><a id="more"></a></p>
<h1 id="Java内存区域与内存溢出异常"><a href="#Java内存区域与内存溢出异常" class="headerlink" title="Java内存区域与内存溢出异常"></a>Java内存区域与内存溢出异常</h1><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>　　程序计数器是一块较小的内存空间，它可以看作是当前线程所执行字节码的行号指示器。</p>
<p>　　Java虚拟机的多线程是通过线程的轮流切换并分配处理器执行时间的方式来实现的，因此为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<p>　　<strong>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</strong></p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>　　与程序计数器一样，Java虚拟机栈也是线程私有的。它的生命周期与线程相同。</p>
<p>　　虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p>　　局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型）和returnAddress（指向了一条字节码指令地址）。</p>
<p>　　其中64位长度的long和double类型的数据会占用2个局部变量的空间，其余的数据类型只占用一个。</p>
<p><strong>局部变量表所需的内存空间在编译期间完成分配</strong>，当进入一个方法时，<strong>这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</strong></p>
<p>　　在Java虚拟机规范中，对这个区域规定了两种异常情况：如果线程请求的深度大于虚拟机所允许的深度，将跑出StackOverflowError异常；如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>　　本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈微虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。</p>
<p>　　与虚拟机栈一样，本地方法栈区域也会跑出StackOverflowError和OutMemoryError异常。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>　　Java堆是被所有内存共享的一块区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p>
<p>　　Java堆是垃圾收集器管理的主要区域，因此很多时候也被称作“GC堆”。</p>
<p>　　根据Java虚拟机规范的规定，Java对可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存完成实例的分配，并且堆也无法在扩展时，将会跑出OutOfMemoryError异常。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>　　方法去与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码数据。</p>
<p>　　根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>　　运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号应用，这部分内容将在类加载后进入方法区的运行时常量池存放。</p>
<h2 id="虚拟机对象探秘"><a href="#虚拟机对象探秘" class="headerlink" title="虚拟机对象探秘"></a>虚拟机对象探秘</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>　　虚拟机遇到一条new指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须执行相应的类加载过程。</p>
<p>　　在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成之后便可以完全确定（参考Java虚拟机栈）。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来（分配方式有指针碰撞和空闲列表）。</p>
<p>　　内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型对应的零值。</p>
<p>　　接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄信息。这些信息存放在对象的对象头之中。</p>
<p>　　在上面的工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象的创建才刚刚开始————<init>方法还没有执行，所有的字段都还为零。所以一般来说（由字节码中是否跟随invokespecial指令决定），执行new指令之后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</init></init></p>
<h3 id="对象的内存区域"><a href="#对象的内存区域" class="headerlink" title="对象的内存区域"></a>对象的内存区域</h3><p>　　在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域，对象头，实例数据和对齐填充。</p>
<p>　　HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果一个对象是Java数组，那在对象头中还必须有一块用于记录数组长度的数据。</p>
<p>　　接下来的实例数据部分是对象真正存储的信息，也是在程序代码中所定义的各种类型的字段内容。</p>
<p>　　第三部分对齐填充并不是必然存在的，也没有特别含义，他仅仅起着占位的作用。由于HotSpot VM 的自动内存管理系统要求对象的起始地址必须是8字节的整数倍，对象头部分正好是8字节的倍数（1倍或2倍），因此，当对象实例数据部分没有对齐是，局需要通过对齐填充来补全。</p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>　　建立对象是为了适用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象，由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位，访问堆中具体对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有<strong>使用句柄</strong>和<strong>直接指针</strong>两种。</p>
<ul>
<li>如果使用句柄访问的话，那么在Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</li>
<li>如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。</li>
</ul>
<p>　　这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的示例数据指针，而reference本身不需要修改。</p>
<p>　　使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销。由于对象访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。</p>
<p>　　就HotSpot而言，它是使用第二种方式进行对象访问的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis 安装（linux）]]></title>
      <url>http://yoursite.com/2016/12/06/Redis%E5%AE%89%E8%A3%85%EF%BC%88Linux%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="Linux下redis安装"><a href="#Linux下redis安装" class="headerlink" title="Linux下redis安装"></a>Linux下redis安装</h1><p>下载redis安装包，本文中所有安装包为 redis-3.2.1.tar.gz。<br><a id="more"></a></p>
<p>解压</p>
<p>检查是否安装gcc<br>执行gcc命令判断，如果未安装，执行 yum -y install gcc</p>
<p>进入解压后的根目录下 执行make命令</p>
<p>进入src目录下 执行make install 命令</p>
<p>编辑 根目录下redis.conf<br>daemonize yes   //改为守护进程</p>
<p>回到根目录下执行 redis-server redis.conf 启动服务</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring MVC]]></title>
      <url>http://yoursite.com/2016/11/30/Spring%20MVC/</url>
      <content type="html"><![CDATA[<h1 id="Spring-MVC-请求"><a href="#Spring-MVC-请求" class="headerlink" title="Spring MVC 请求"></a>Spring MVC 请求</h1><p>请求的第一站是Spring 的 DispatcherServlet。</p>
<p>DispatcherServlet 的任务是将请求发送给Spring MVC控制器（controller），DispatcherServlet 根据处理器映射来决定将请求发送到哪里。</p>
<p>到了控制器，请求会卸下负载（用户提交的信息），控制器开始处理请求。</p>
<p>控制器在完成逻辑处理之后，通常会产生一些信息，信息需要发送给一个视图（通常是JSP），用来展示给用户。<br><a id="more"></a></p>
<p>控制器做的最后一件事情就是将模型数据打包，并标示出用于渲染输出的视图名，接下来控制器会将请求连同模型和视图名发送回 DispatcherServlet。</p>
<p>DispatcherServlet 将使用视图解析器将逻辑视图名匹配为一个特定的视图实现。</p>
<p>最后一站是视图的实现，它将模型数据交付给视图进行渲染输出。</p>
<h1 id="搭建Spring-MVC"><a href="#搭建Spring-MVC" class="headerlink" title="搭建Spring MVC"></a>搭建Spring MVC</h1><p>DispatcherServlet 是Spring MVC的核心，他负责将请求路由到其他的组件当中。</p>
<h2 id="使用java-配置-DispatcherServlet（仅适用于Servlet3-0及以上的环境中）"><a href="#使用java-配置-DispatcherServlet（仅适用于Servlet3-0及以上的环境中）" class="headerlink" title="使用java 配置 DispatcherServlet（仅适用于Servlet3.0及以上的环境中）"></a>使用java 配置 DispatcherServlet（仅适用于Servlet3.0及以上的环境中）</h2><p>第一步：将 DispatcherServlet 配置在 Servlet容器中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;</div><div class="line"></div><div class="line">public class SpittrWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected Class&lt;?&gt;[] getRootConfigClasses() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return new Class&lt;?&gt;[]&#123; RootConfig.class&#125;;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected Class&lt;?&gt;[] getServletConfigClasses() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return new Class&lt;?&gt;[]&#123; WebConfig.class&#125;;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected String[] getServletMappings() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return new String[]&#123;&quot;/&quot;,&quot;&quot;&#125;;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码究竟是如何工作的呢？</p>
<blockquote>
<p> 在Servlet 3.0环境中，容器会在类路径下查找实现了 javax.servlet.ServletContainerInitializer 接口的类，如果能发现，就会用它来配置Servlet 容器</p>
<p> Spring 提供了这个接口的实现，名为 SpringServletContainerInitializer ，这个了会反过来查找实现了 WebApplicationInitializer 的类并将配置任务交给它们来完成。</p>
<p> 上述代码中继承的类就是在Spring 3.2 中引入的一个 WebApplicationInitializer 的基础实现。</p>
<p> 因此当部署到Servlet 3.0 容器中的时候，容器就会自动发现它并用它来配置Servlet上下文。</p>
</blockquote>
<p>第二步：启用Spring MVC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">import org.springframework.context.annotation.Bean;</div><div class="line">import org.springframework.context.annotation.ComponentScan;</div><div class="line">import org.springframework.context.annotation.Configuration;</div><div class="line">import org.springframework.web.servlet.ViewResolver;</div><div class="line">import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;</div><div class="line">import org.springframework.web.servlet.config.annotation.EnableWebMvc;</div><div class="line">import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</div><div class="line">import org.springframework.web.servlet.view.InternalResourceViewResolver;</div><div class="line"></div><div class="line">@Configuration</div><div class="line">@EnableWebMvc     //启用Spring MVC</div><div class="line">@ComponentScan(&quot;spittr.web&quot;) //启用组件扫描</div><div class="line">public class WebConfig extends WebMvcConfigurerAdapter&#123;</div><div class="line"></div><div class="line">	@Bean    //配置JSP视图解析器</div><div class="line">	public ViewResolver viewResolver()&#123;</div><div class="line">		InternalResourceViewResolver resolver = new InternalResourceViewResolver();</div><div class="line">		resolver.setPrefix(&quot;/WEB-INF/views/&quot;);</div><div class="line">		resolver.setSuffix(&quot;.jsp&quot;);</div><div class="line">		resolver.setExposeContextBeansAsAttributes(true);</div><div class="line">		return resolver;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override   //配置静态资源处理</div><div class="line">	public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		configurer.enable();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>第三步：配置RootConfig </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import org.springframework.context.annotation.ComponentScan;</div><div class="line">import org.springframework.context.annotation.ComponentScan.Filter;</div><div class="line">import org.springframework.web.servlet.config.annotation.EnableWebMvc;</div><div class="line">import org.springframework.context.annotation.Configuration;</div><div class="line">import org.springframework.context.annotation.FilterType;</div><div class="line"></div><div class="line">@Configuration</div><div class="line">@ComponentScan(basePackages = &#123; &quot;spittr&quot; &#125;, excludeFilters = &#123;</div><div class="line">		@Filter(type = FilterType.ANNOTATION, value = EnableWebMvc.class) &#125;)</div><div class="line">public class RootConfig &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过以上三步，我们的Spring MVC就已经初步搭建完成了。</p>
<p><strong>值得注意的是，如果在第一步配置中，getServletMappings 方法中只映射了 <code>/</code>,当你在你的controller中也只映射了斜线的话，这并不能拦截根路径的请求，他会默认跳转到webRoot目录下的index.jsp,除非删除这个index.jsp或者在 getServletMappings 方法中加上多空字符串的映射。</strong></p>
<h1 id="接受请求的输入"><a href="#接受请求的输入" class="headerlink" title="接受请求的输入"></a>接受请求的输入</h1><p>Spring MVC 中允许以多种方式将客户端中的数据传送到控制器的处理器方法中，包括：<br>1.查询参数<br>2.表单参数<br>3.路径变量</p>
<blockquote>
<p>针对查询参数，可以使用 <code>RequestParam</code> 注解来接收，不传参数时可以通过 <code>defaultValue</code> 指定默认值。</p>
</blockquote>
<p>eg: </p>
<p><code>public void getSpittle(@RequestParam(&quot;max&quot;) long max)</code></p>
<p><code>public void getSpittle(@RequestParam(value=&quot;max&quot;,defaultValue=20) long max)</code></p>
<blockquote>
<p>针对路径变量，可以使用占位符 <code>{}</code>,占位符部分可以是任意值。</p>
</blockquote>
<p>eg:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(value=&quot;/&#123;spittleId&#125;&quot;)</div><div class="line">public void getSpittle(@pathVariable（&quot;spittleId&quot;） long spittleId)</div></pre></td></tr></table></figure>
<p><code>@pathVariable</code> 注解表示不管占位符部分的值是什么，都会传递到处理器方法的 <code>spittleId</code> 参数中，如对“spittles/12345”发送get请求，那么spittleId 的值为 12345.</p>
<p>如果方法的参数名称和占位符的名称相同，可以去掉<code>@pathVariable</code> 中的value 属性。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring4(1) 装配Bean]]></title>
      <url>http://yoursite.com/2016/11/22/Spring4-1/</url>
      <content type="html"><![CDATA[<h1 id="自动化装配Bean"><a href="#自动化装配Bean" class="headerlink" title="自动化装配Bean"></a>自动化装配Bean</h1><h2 id="创建可被发现的bean"><a href="#创建可被发现的bean" class="headerlink" title="创建可被发现的bean"></a>创建可被发现的bean</h2><h3 id="java中进行配置"><a href="#java中进行配置" class="headerlink" title="java中进行配置"></a>java中进行配置</h3><ul>
<li>在需要被自动化装配的类上加上 <code>@Component</code> 注解，该注解表明该类会作为组件类，并告知spring要为这个类创建bean。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package com.gdn.demo2;</div><div class="line"></div><div class="line">import org.springframework.stereotype.Component;</div><div class="line"></div><div class="line">@Component</div><div class="line">public class Man implements Person &#123;</div><div class="line">	private String name;</div><div class="line">	</div><div class="line">	public Man(String name) &#123;</div><div class="line">		super();</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setName(String name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>那么我们如何为组件扫描的bean命名呢？一共有两种方案来实现。</p>
<p>第一种方案是还是采用 <code>@Component</code> 注解： <code>@Component（&quot;man&quot;）</code></p>
<p>第二种方案则不再采用 <code>@Component</code> 注解，而是使用Java依赖注入规范中所提供的 <code>@Named</code> 注解来为bean设置ID：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package com.gdn.demo2;</div><div class="line"></div><div class="line">import javax.inject.Named;</div><div class="line"></div><div class="line">@Named(&quot;man&quot;)</div><div class="line">public class Man implements Person &#123;</div><div class="line">	private String name;</div><div class="line">	</div><div class="line">	public Man(String name) &#123;</div><div class="line">		super();</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setName(String name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>由于组件扫面默认是不启用的，我们还需要显示的配置一下spring，让他去寻找带有 <code>@Component</code> 注解的类。配置如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">package com.gdn.demo2;</div><div class="line"></div><div class="line">import org.springframework.context.annotation.ComponentScan;</div><div class="line">import org.springframework.context.annotation.Configuration;</div><div class="line"></div><div class="line">@Configuration</div><div class="line">@ComponentScan</div><div class="line">public class BedConfig &#123;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上面你的配置所示， <code>@ComponentScan</code> 默认会扫描与配置类同包以及子包下的类。遇到带有 <code>@Component</code> 注解的类就会自动为其创建一个bean。</p>
<p>那么我们如何制定不同的基础包呢？</p>
<p>只需在 <code>@ComponentScan</code> 的value属性中指明包的名称即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Configuration</div><div class="line">@ComponentScan(&quot;com.gdn.demo2&quot;)</div><div class="line">public class BedConfig &#123;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果想要更加清晰的表明所设置的包是基础包，可以通过 basePackages 属性进行配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Configuration</div><div class="line">@ComponentScan(basePackages=&quot;com.gdn.demo2&quot;)</div><div class="line">public class BedConfig &#123;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除此之外，我们还可以设置多个基础包，只需将 basePackages 的属性值设置成一个数组即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Configuration</div><div class="line">@ComponentScan(basePackages=&#123;&quot;com.gdn.demo1&quot;,&quot;com.gdn.demo2&quot;&#125;)</div><div class="line">public class BedConfig &#123;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的配置中不难发现，所有设置的基础包都是以String类型表示的，这种方法是类型不安全的，当进行代码重构时，可能会引发错误。</p>
<p>所以除了上述方法之外， <code>@ComponentScan</code>还提供了另一种方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Configuration</div><div class="line">@ComponentScan(basePackageClasses=&#123;demo1.class,demo2.class&#125;)</div><div class="line">public class BedConfig &#123;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="通过xml进行配置"><a href="#通过xml进行配置" class="headerlink" title="通过xml进行配置"></a>通过xml进行配置</h3><p>如果想要通过xml配置的方式启用组件扫描的话，需要引入Spring context命名空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div class="line">	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">	xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</div><div class="line">	xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</div><div class="line">	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd&quot;&gt;</div><div class="line"></div><div class="line">	&lt;context:component-scan base-package=&quot;com.gdn.demo2&quot;&gt;&lt;/context:component-scan&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>通过上面的配置，我们已经定义完成了可以被Spring发现的bean，接下来要做的工作就是进行自动装配。</p>
<p>为了声明要进行自动装配，可以借助Spring的 <code>@Autowired</code> 注解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package com.gdn.demo2;</div><div class="line"></div><div class="line">import org.springframework.beans.factory.annotation.Autowired;</div><div class="line">import org.springframework.stereotype.Component;</div><div class="line"></div><div class="line">@Component</div><div class="line">public class Bed &#123;</div><div class="line"></div><div class="line">	private Man man;</div><div class="line">	private Women women;</div><div class="line"></div><div class="line">	@Autowired(required = false)</div><div class="line">	public Bed(Man man,Women women)&#123;</div><div class="line">		this.man = man;</div><div class="line">		this.women = women;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void MakeBaby()&#123;</div><div class="line">		System.out.println(man.getName() + &quot;和&quot; + women.getName() + &quot;生了一个小baby！&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码中，在bed的构造器上添加了 <code>@Autowired</code> 注解。这表明当Spring创建Bed bean时，会通过这个构造器来实例化并会传入Man 和 Women 类型的bean。</p>
<p><code>@Autowired</code> 注解也可以用在属性的Setter方法上。</p>
<p>Setter方法并没有什么特殊之处，所以 <code>@Autowired</code> 注解可以用在类的任何方法上，不管构造器、Setter方法还是其他的方法，Spring都会尝试满足方法参数上所声明的依赖。</p>
<p><code>@Autowired(required = false)</code> 注解的require属性值如果设置为false，那么当spring没有找的匹配的bean时，spring会让这个bean处于未装配的状态，否则则会抛出异常。</p>
<h1 id="显示装配Bean"><a href="#显示装配Bean" class="headerlink" title="显示装配Bean"></a>显示装配Bean</h1><p>除了自动装配之外，我们还可以显示的装配我们需要的Bean。</p>
<h2 id="通过java配置进行显示装配"><a href="#通过java配置进行显示装配" class="headerlink" title="通过java配置进行显示装配"></a>通过java配置进行显示装配</h2><h3 id="声明（创建）Bean"><a href="#声明（创建）Bean" class="headerlink" title="声明（创建）Bean"></a>声明（创建）Bean</h3><p>创建JavaConfig类的关键在于为其添加 <code>Configuration</code> 注解。</p>
<p>要在JavaConfig中声明Bean，需要编写一个方法，这个方法创建所需类型的实例，然后给这个方法添加 <code>@Bean</code> 注解。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">package com.gdn.demo2;</div><div class="line"></div><div class="line">import org.springframework.context.annotation.Bean;</div><div class="line">import org.springframework.context.annotation.Configuration;</div><div class="line"></div><div class="line">@Configuration</div><div class="line">public class BedConfig &#123;</div><div class="line">	</div><div class="line">	@Bean(name=&quot;man&quot;)  //此处不指定name属性的值，则bean的名称和方法名相同。此处为man</div><div class="line">	public Man man()&#123;</div><div class="line">		return new Man(&quot;xiaomng&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Bean</div><div class="line">	public Women women()&#123;</div><div class="line">		return new Women(&quot;baby&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Bean</div><div class="line">	public Bed bed()&#123;</div><div class="line">		return new Bed(man(), women());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="实现注入（装配）"><a href="#实现注入（装配）" class="headerlink" title="实现注入（装配）"></a>实现注入（装配）</h3><p>在JavaConfig中装配bean最简单的方法就是引用创建的bean的方法。如上面声明Bean的JavaConfig中的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Bean</div><div class="line">public Bed bed()&#123;</div><div class="line">	return new Bed(man(), women());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在创建bed 的 bean时引用了man()和women()两个方法。</p>
<p>注：值得注意的是，虽然man 是调用man()得到的，但其实并非完全如此。因为man()上添加了 <code>@Bean</code> 注解，spring将会拦截所有对他的调用，并确保直接返回该方法所创建的bean，而不是每次都对其进行实际的调用。</p>
<p>比如在写一个anotherBed的方法，两次传入的bean（man和women）完全一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Bean</div><div class="line">public Bed bed()&#123;</div><div class="line">	return new Bed(man(), women());</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Bean</div><div class="line">public Bed anotherBed()&#123;</div><div class="line">	return new Bed(man(), women());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>所以说，默认情况下，spring中所有的bean都是单例的。</strong></p>
<p>除此之外，我们还有另外一种方式装配bean。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Bean</div><div class="line">public Bed bed(Man man，Women women)&#123;</div><div class="line">	return new Bed(man, women);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，bed() 方法请求了一个Man 和一个 Women 作为参数，当Spring调用bed()创建bed bean的时候，就会自动转配一个Man 和 Women 到配置方法之中。</p>
<p>这种方法不需要明确的引用Man 或者 Women的@Bean 方法，而且不需要将Man 或者 Women的@Bean 方法声明到同一个配置类当中。</p>
<p><strong>所以说，通过第二种方式引用其他的 bean 通常是最佳的选择</strong></p>
<h2 id="通过XML配置进行显示装配"><a href="#通过XML配置进行显示装配" class="headerlink" title="通过XML配置进行显示装配"></a>通过XML配置进行显示装配</h2><h3 id="声明（创建）Bean-1"><a href="#声明（创建）Bean-1" class="headerlink" title="声明（创建）Bean"></a>声明（创建）Bean</h3><p>要在基于XML 的Spring 配置中声明一个bean，我们需要使用一个元素：<bean>。在这里<bean> 元素类似于JavaConfig 中的 <code>@Bean</code> 注解。</bean></bean></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div class="line">	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">	xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</div><div class="line">	xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</div><div class="line">	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd&quot;&gt;</div><div class="line"></div><div class="line">	&lt;bean class=&quot;com.gdn.demo2.Bed&quot; id=&quot;bed&quot;&gt;&lt;/bean&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>注：如果上述配置中不指定id属性，bean将根据全限定类名来进行命名，本例中bean的ID 将会是 <code>com.gdn.demo2.Bed#0</code> ,其中#0是一个计数方式，如果同时声明了另外一个Bed，并且也没有指定id,则其自动得到的id将会是 <code>com.gdn.demo2.Bed#1</code>。</p>
<h3 id="实现注入（装配）-1"><a href="#实现注入（装配）-1" class="headerlink" title="实现注入（装配）"></a>实现注入（装配）</h3><h4 id="注入引用"><a href="#注入引用" class="headerlink" title="注入引用"></a>注入引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div class="line">	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">	xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</div><div class="line">	xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</div><div class="line">	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd&quot;&gt;</div><div class="line"></div><div class="line">	&lt;bean class=&quot;com.gdn.demo2.Man&quot; id=&quot;man&quot;&gt;&lt;/bean&gt;</div><div class="line">	&lt;bean class=&quot;com.gdn.demo2.Women&quot; id=&quot;women&quot;&gt;&lt;/bean&gt;</div><div class="line">	&lt;bean class=&quot;com.gdn.demo2.Bed&quot; id=&quot;bed&quot;&gt;</div><div class="line">		&lt;constructor-arg ref=&quot;man&quot; /&gt;</div><div class="line">		&lt;constructor-arg ref=&quot;women&quot; /&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>除了上述配置之外，我们还可以采用Spring的c-命名空间（Spring3.0中引入的）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div class="line">	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">	xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</div><div class="line">	xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</div><div class="line">	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd&quot;</div><div class="line"></div><div class="line">	&lt;bean class=&quot;com.gdn.demo2.Man&quot; id=&quot;man&quot;&gt;&lt;/bean&gt;</div><div class="line">	&lt;bean class=&quot;com.gdn.demo2.Women&quot; id=&quot;women&quot;&gt;&lt;/bean&gt;</div><div class="line"></div><div class="line">	&lt;bean class=&quot;com.gdn.demo2.Bed&quot; id=&quot;bed&quot; c:man-ref=&quot;man&quot; c:women-ref=&quot;women&quot;/&gt;</div><div class="line">		</div><div class="line"></div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>上述配置中，”c:” 是c-命名空间前缀，”man”是构造器参数名，”ref” 是注入bean的引用，”man”是要注入bean的id。</p>
<p>同样运用c-命名空间，但是我们可以换另一种写法，这种写法不需要构造器的参数名称,而是将参数的名称换成参数的索引，由于XML中不允许数字作为属性的第一个字符，所以必须添加一个下划线作为前缀。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;com.gdn.demo2.Bed&quot; id=&quot;bed&quot; c:_0-ref=&quot;man&quot; c:_1-ref=&quot;women&quot;/&gt;</div></pre></td></tr></table></figure>
<p>如果只有一个构造参数，我们可以不用去表示参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;com.gdn.demo2.Bed&quot; id=&quot;bed&quot; c:_-ref=&quot;man&quot;/&gt;</div></pre></td></tr></table></figure>
<h4 id="注入字面量"><a href="#注入字面量" class="headerlink" title="注入字面量"></a>注入字面量</h4><p>此处不在详细介绍，只列出简单写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;com.gdn.demo2.Say&quot; id=&quot;say&quot;&gt;</div><div class="line">	&lt;constructor-arg value=&quot;hello word!&quot; /&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;com.gdn.demo2.Say&quot; id=&quot;say&quot; c:_title=&quot;hello word!&quot;/&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;com.gdn.demo2.Say&quot; id=&quot;say&quot; c:_0=&quot;hello word!&quot;/&gt;</div></pre></td></tr></table></figure>
<h3 id="装配集合"><a href="#装配集合" class="headerlink" title="装配集合"></a>装配集合</h3><p>在装配集合时，c-命名空间是无法做到的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;com.gdn.demo2.Say&quot; id=&quot;say&quot;&gt;</div><div class="line">	&lt;constructor-arg&gt;&lt;null/&gt;&lt;/constructor-arg&gt;  //将集合设置为null。</div><div class="line">	&lt;constructor-arg&gt;</div><div class="line">		&lt;list&gt;</div><div class="line">	`		&lt;value&gt;hello&lt;value&gt;</div><div class="line">			&lt;value&gt;word&lt;value&gt;</div><div class="line">			&lt;value&gt;!&lt;value&gt;</div><div class="line">		&lt;/list&gt;</div><div class="line">	&lt;/constructor-arg&gt;</div><div class="line"></div><div class="line">	&lt;constructor-arg&gt;</div><div class="line">		&lt;list&gt;</div><div class="line">	`		&lt;ref bean=&quot;man&quot;&gt;</div><div class="line">			&lt;ref bean=&quot;women&quot;&gt;</div><div class="line">		&lt;/list&gt;</div><div class="line">	&lt;/constructor-arg&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>当构造器的参数是java.util.List时，使用<list>集合是合理的。尽管如此，我们可以按照同样的方式是用<set>元素：</set></list></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;com.gdn.demo2.Say&quot; id=&quot;say&quot;&gt;</div><div class="line">	&lt;constructor-arg&gt;&lt;null/&gt;&lt;/constructor-arg&gt;  //将集合设置为null。</div><div class="line">	&lt;constructor-arg&gt;</div><div class="line">		&lt;set&gt;</div><div class="line">	`		&lt;value&gt;hello&lt;value&gt;</div><div class="line">			&lt;value&gt;word&lt;value&gt;</div><div class="line">			&lt;value&gt;!&lt;value&gt;</div><div class="line">		&lt;/set&gt;</div><div class="line">	&lt;/constructor-arg&gt;</div><div class="line"></div><div class="line">	&lt;constructor-arg&gt;</div><div class="line">		&lt;set&gt;</div><div class="line">	`		&lt;ref bean=&quot;man&quot;&gt;</div><div class="line">			&lt;ref bean=&quot;women&quot;&gt;</div><div class="line">		&lt;/set&gt;</div><div class="line">	&lt;/constructor-arg&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p><strong><set> 和 <list> 区别不大，其中最重要的不同在于当Spring创建要装配的集合时，所创建的是java.util.List 还是 java.util.Set ，如果是Set的话，则所有重复的值都会被忽略掉，存放顺序也不会得到保证。</list></set></strong></p>
<p><strong>不论在那种情况<set> 和 <list> 都可以装配List Set 甚至数组</list></set></strong></p>
<h3 id="设置属性"><a href="#设置属性" class="headerlink" title="设置属性"></a>设置属性</h3><p>在上述的方法中，全部是采用构造器注入的方式实现bean的装配。下面将介绍如何使用Spring XML 实现属性注入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">package com.gdn.demo2;</div><div class="line"></div><div class="line">import org.springframework.beans.factory.annotation.Autowired;</div><div class="line">import org.springframework.stereotype.Component;</div><div class="line"></div><div class="line">public class Bed &#123;</div><div class="line"></div><div class="line">	private Man man;</div><div class="line">	private Women women;</div><div class="line">	</div><div class="line">	@Autowired</div><div class="line">	public void setMan(Man man) &#123;</div><div class="line">		this.man = man;</div><div class="line">	&#125;</div><div class="line">	@Autowired</div><div class="line">	public void setWomen(Women women) &#123;</div><div class="line">		this.women = women;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void MakeBaby()&#123;</div><div class="line">		System.out.println(man.getName() + &quot;和&quot; + women.getName() + &quot;生了一个小baby！&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据上述代码，我们可以采用如下的配置方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;com.gdn.demo2.Man&quot; id=&quot;man&quot;&gt;&lt;/bean&gt;</div><div class="line">&lt;bean class=&quot;com.gdn.demo2.Women&quot; id=&quot;women&quot;&gt;&lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;bean class=&quot;com.gdn.demo2.Bed&quot; id=&quot;bed&quot;&gt;</div><div class="line">	&lt;property name=&quot;man&quot; ref=&quot;man&quot; /&gt;</div><div class="line">	&lt;property name=&quot;women&quot; ref=&quot;women&quot; /&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>除了使用<property> 元素，我们也可以使用p-命名空间：</property></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;com.gdn.demo2.Man&quot; id=&quot;man&quot;&gt;&lt;/bean&gt;</div><div class="line">&lt;bean class=&quot;com.gdn.demo2.Women&quot; id=&quot;women&quot;&gt;&lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;bean class=&quot;com.gdn.demo2.Bed&quot; id=&quot;bed&quot;&gt;</div><div class="line">	&lt;p:man-ref=&quot;man&quot; /&gt;</div><div class="line">	&lt;p:women-ref=&quot;women&quot; /&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>使用<property> 元素 或者p-命名空间 注入字面量和集合</property></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;com.gdn.demo2.Say&quot; id=&quot;say&quot;&gt;</div><div class="line">	&lt;property name=&quot;title&quot; value=&quot;hello word!&quot; /&gt;</div><div class="line">	&lt;p:title=&quot;hello word!&quot; /&gt;</div><div class="line">	&lt;property name=&quot;titles&quot;&gt;</div><div class="line">		&lt;list&gt;</div><div class="line">			&lt;value&gt;hello&lt;/value&gt;</div><div class="line">			&lt;value&gt;word&lt;/value&gt;</div><div class="line">			&lt;value&gt;!&lt;/value&gt;</div><div class="line">		&lt;/list&gt;</div><div class="line">	&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>那么针对构造器注入和属性注入应该选择哪一个呢？</p>
<p><strong>作为一个通用的规则，对于强依赖使用构造器注入，而对可选性的依赖使用属性注入。</strong></p>
<h1 id="混合配置"><a href="#混合配置" class="headerlink" title="混合配置"></a>混合配置</h1><h2 id="JavaConfig中合并"><a href="#JavaConfig中合并" class="headerlink" title="JavaConfig中合并"></a>JavaConfig中合并</h2><h3 id="JavaConfig中引入JavaConfig"><a href="#JavaConfig中引入JavaConfig" class="headerlink" title="JavaConfig中引入JavaConfig"></a>JavaConfig中引入JavaConfig</h3><p>实现在JavaConfig中引入JavaConfig 使用 <code>@Import</code>  注解：</p>
<p><code>@Import(yourConfig.class)</code><br><code>@Import({yourConfig1.class,yourConfig2.class})</code></p>
<h3 id="JavaConfig中引入XML"><a href="#JavaConfig中引入XML" class="headerlink" title="JavaConfig中引入XML"></a>JavaConfig中引入XML</h3><p>实现在JavaConfig中引入JavaConfig 使用 <code>@ImportResource</code>  注解：</p>
<p><code>@ImportResource(classpath:yourConfig.xml)</code></p>
<p>注：yourConfig.xml 需放在根类路径下。</p>
<h2 id="XML中合并"><a href="#XML中合并" class="headerlink" title="XML中合并"></a>XML中合并</h2><h3 id="XML中引入XML"><a href="#XML中引入XML" class="headerlink" title="XML中引入XML"></a>XML中引入XML</h3><p>实现在XML中引入XML 使用 <code>&lt;import&gt;</code> 元素：</p>
<p><code>&lt;import resoune=&quot;yourConfig.xml&quot;&gt;</code></p>
<h3 id="XML中引入JavaConfig"><a href="#XML中引入JavaConfig" class="headerlink" title="XML中引入JavaConfig"></a>XML中引入JavaConfig</h3><p>实现在XML中引入JavaConfig 使用 <code>&lt;bean&gt;</code> 元素：</p>
<p><code>&lt;bean class=&quot;yourConfig&quot;&gt;</code></p>
<p><strong>在合并这些配置文件中，我们可以创建一个更高层次的配置文件，这个文件中不声明任何的bean，只是负责将多个配置组合起来。</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo环境搭建(windows)]]></title>
      <url>http://yoursite.com/2016/11/16/Hexo/</url>
      <content type="html"><![CDATA[<p>这是一篇有关如何使用github Pages和Hexo搭建自己独立博客的详尽教程，里面介绍了如何使用和配置Hexo框架，如何将Hexo部署到自己的github项目中，域名注册，以及域名的绑定等功能。<br><a id="more"></a></p>
<h1 id="依赖环境安装"><a href="#依赖环境安装" class="headerlink" title="依赖环境安装"></a>依赖环境安装</h1><h2 id="Node-js的安装"><a href="#Node-js的安装" class="headerlink" title="Node.js的安装"></a>Node.js的安装</h2><p><a href="https://nodejs.org/en/" target="_blank" rel="external">下载Node.js</a></p>
<img src="/2016/11/16/Hexo/1.png" alt="1.png" title="">
<p>本文下载的版本是当时的最新版6.3.0。下载完成后安装即可。</p>
<p>查看是否安装成功:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node -v</div></pre></td></tr></table></figure>
<p>出现如下图所示内容代表Node.js安装成功</p>
<img src="/2016/11/16/Hexo/2.png" alt="2.png" title="">
<h2 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h2><p>请自行谷歌。</p>
<p>查看是否安装成功:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git --version</div></pre></td></tr></table></figure>
<p>出现如下图所示内容代表Git安装成功</p>
<img src="/2016/11/16/Hexo/3.png" alt="3.png" title="">
<h2 id="Hexo的安装"><a href="#Hexo的安装" class="headerlink" title="Hexo的安装"></a>Hexo的安装</h2><p>以管理员身份运行cmd执行如下命令</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g hexo-cli</div></pre></td></tr></table></figure>
<p>最后会出现大概这么一条信息 <img src="/2016/11/16/Hexo/4.png" alt="4.png" title=""></p>
<p>说明hexo 已经安装成功了。</p>
<h3 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h3><p>接下来，我们选择一个硬盘目录作为存放我们博客的路径，例如我手动在E盘目录下建了一个blog的文件夹，然<br>后执行以下命令完成hexo 的初始化。</p>
<blockquote>
<p>注：如不指定 e:\blog 则在当前文件夹完成hexo的初始化</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo init e:\blog</div></pre></td></tr></table></figure>
<p>进入该目录，执行如下命令，系统会可以根据package.json文件中dependencies的配置安装所有依赖包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install</div></pre></td></tr></table></figure></p>
<h3 id="生成部署文件"><a href="#生成部署文件" class="headerlink" title="生成部署文件"></a>生成部署文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo g</div></pre></td></tr></table></figure>
<h3 id="启动本地服务器"><a href="#启动本地服务器" class="headerlink" title="启动本地服务器"></a>启动本地服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo s</div></pre></td></tr></table></figure>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#生成静态文件，会在当前目录下生成一个新的叫做public的文件夹</div><div class="line">hexo generate (hexo g) </div><div class="line"></div><div class="line">#启动本地web服务，用于博客的预览</div><div class="line">hexo server (hexo s) </div><div class="line"></div><div class="line">#部署博客到远端服务器</div><div class="line">hexo deploy (hexo d)</div><div class="line"></div><div class="line">#新建文章</div><div class="line">hexo new fileName  </div><div class="line"></div><div class="line">#新建页面</div><div class="line">hexo new page</div></pre></td></tr></table></figure>
<p><a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="external">更多指令&gt;&gt;</a></p>
<h1 id="部署博客到github-Pages"><a href="#部署博客到github-Pages" class="headerlink" title="部署博客到github Pages"></a>部署博客到github Pages</h1><p>每个帐号只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。你可以通过<a href="http://username.github.io" target="_blank" rel="external">http://username.github.io</a> 来访问你的个人主页。</p>
<h2 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h2><p>上传文件需要配置ssh key，不然无法上传。 </p>
<p>首先先检查一下本地是否已经存在ssh key,在Git Bash输入以下指令（任意位置点击鼠标右键），检查是否已经存在了SSH keys。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -al ~/.ssh</div></pre></td></tr></table></figure>
<img src="/2016/11/16/Hexo/5.png" alt="5.png" title="">
<p>如上图所示，由于我已经配置过，所以存在红框内的三个文件，我们直接把这三个文件删掉即可。</p>
<p>删除完成后，设置name和email</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name xxx</div><div class="line">git config --global user.email xxx@xxx.com</div></pre></td></tr></table></figure>
<blockquote>
<p>注：需要注意的是这里的name是随意的，邮箱是你的联系邮箱，与github上的邮箱没有什么联系。</p>
</blockquote>
<h2 id="生成ssh-密钥"><a href="#生成ssh-密钥" class="headerlink" title="生成ssh 密钥"></a>生成ssh 密钥</h2><p>输入以下指令（邮箱就是你注册github时候的邮箱）后，回车：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C xxx@xxx.com</div></pre></td></tr></table></figure>
<p>一路按回车键即可，如果设置了密码请记住。 </p>
<p>这一步在~/.ssh/下生成了两个文件id_rsa 和 id_rsa.pub</p>
<h2 id="将秘钥拷贝至github"><a href="#将秘钥拷贝至github" class="headerlink" title="将秘钥拷贝至github"></a>将秘钥拷贝至github</h2><p>拷贝id_rsa.pub的内容拷贝至github上，如下图<br><img src="/2016/11/16/Hexo/6.png" alt="6.png" title=""><br><img src="/2016/11/16/Hexo/7.png" alt="7.png" title=""></p>
<h2 id="测试是否成功"><a href="#测试是否成功" class="headerlink" title="测试是否成功"></a>测试是否成功</h2><p>输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh git@github.com</div></pre></td></tr></table></figure>
<p>成功的话会显示以下的大致内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">The authenticity of host &apos;github.com (192.30.252.128)&apos; can&apos;t be established.</div><div class="line">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</div><div class="line">Are you sure you want to continue connecting (yes/no)? yes</div><div class="line">Warning: Permanently added &apos;github.com,192.30.252.128&apos; (RSA) to the list of known hosts.</div><div class="line">Hi git-xuhao! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</div><div class="line">Connection to github.com closed.</div></pre></td></tr></table></figure>
<h2 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h2><h3 id="配置-config-yml"><a href="#配置-config-yml" class="headerlink" title="配置_config.yml"></a>配置_config.yml</h3><p>编辑hexo初始化目录下的_config.yml，修改Deployment部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#Deployment</div><div class="line">##Docs: https://hexo.io/docs/deployment.html</div><div class="line">#ssh://git@github.com/gengdn/gengdn.github.io</div><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: ssh:</div><div class="line">  branch: master</div></pre></td></tr></table></figure>
<p>其中，repo是我们刚刚建立的远程仓库，换成你自己的仓库，同时因为刚才配置了SSH-Key，所以必须是SSH形式的URL。值得注意的是，每一个: 后面都必须有一个空格，否则会引起错误。</p>
<h3 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h3><p><code>npm install hexo-deployer-git --save</code></p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p><code>hexo deploy</code></p>
<p>现在我们可以通过访问 <a href="http://gengdn.github.io/" target="_blank" rel="external">http://gengdn.github.io/</a> 来访问我们自己的博客啦,可以看到我们的博客已成功搭建，接下来就是一些主题的优化和配置呢。</p>
<h1 id="添加搜索（Local-Search）"><a href="#添加搜索（Local-Search）" class="headerlink" title="添加搜索（Local Search）"></a>添加搜索（Local Search）</h1><h2 id="安装-hexo-generator-search"><a href="#安装-hexo-generator-search" class="headerlink" title="安装 hexo-generator-search"></a>安装 hexo-generator-search</h2><p>在站点的根目录下执行以下命令：</p>
<p><code>npm install hexo-generator-search --save</code></p>
<h2 id="编辑站点配置文件（根目录下的-config-yml）"><a href="#编辑站点配置文件（根目录下的-config-yml）" class="headerlink" title="编辑站点配置文件（根目录下的_config.yml）"></a>编辑站点配置文件（根目录下的_config.yml）</h2><p>新增以下内容到任意位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">search:</div><div class="line">  path: search.xml</div><div class="line">  field: post</div></pre></td></tr></table></figure>
<h1 id="功能点记录"><a href="#功能点记录" class="headerlink" title="功能点记录"></a>功能点记录</h1><h2 id="tags和categories-页面无法显示"><a href="#tags和categories-页面无法显示" class="headerlink" title="tags和categories 页面无法显示"></a>tags和categories 页面无法显示</h2><p>在hexo初始化的根目录下执行如下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo new page tags</div><div class="line">hexo new page categories</div></pre></td></tr></table></figure>
<p>执行完上述两条命令之后会在source文件下生成两个对应的文件夹，修改文件夹内的index.md文件，将如下内容拷贝纸对应的index.md即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: categories</div><div class="line">date: 2016-07-13 20:58:32</div><div class="line">type: &quot;categories&quot;</div><div class="line">comments: true</div><div class="line">---</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: tags</div><div class="line">date: 2016-07-13 20:58:07</div><div class="line">type: &quot;tags&quot;</div><div class="line">comments: true</div><div class="line">---</div></pre></td></tr></table></figure>
<h2 id="添加本地资源"><a href="#添加本地资源" class="headerlink" title="添加本地资源"></a>添加本地资源</h2><h3 id="资源文件夹"><a href="#资源文件夹" class="headerlink" title="资源文件夹"></a>资源文件夹</h3><p>Hexo提供了组织化的方式来管理资源,资源可以分布在各个文章上，通过将 config.yml文件中的 post_asset_folder 选项设为 true 来打开</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">post_asset_folder: true</div></pre></td></tr></table></figure>
<p>资源文件管理功能打开后，Hexo将会在每一次通过 hexo new title命令创建新文章时自动创建一个文件夹,这个资源文件夹与 markdown 文件同名。将所有与文章有关的资源放在这个关联文件夹中，可以通过相对路径来引用它们</p>
<h3 id="资源的引用"><a href="#资源的引用" class="headerlink" title="资源的引用"></a>资源的引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% asset_img slug [title] %&#125;</div><div class="line">&#123;% asset_link slug [title] %&#125;</div><div class="line">&#123;% asset_path slug %&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注：slug 替换为资源路径<br>[title] 替换为文字，可为空</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eg:  &#123;% asset_img 5.png  %&#125;</div></pre></td></tr></table></figure>
<h1 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h1><ul>
<li><a href="http://ms.csdn.net/geek/72697" target="_blank" rel="external">基于Hexo+GitHub Pages 免费搭建个人博客最强教程</a></li>
<li><a href="http://theme-next.iissnan.com/" target="_blank" rel="external">NexT主题</a></li>
<li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">Hexo文档</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://yoursite.com/2016/11/16/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.<br><a id="more"></a></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
