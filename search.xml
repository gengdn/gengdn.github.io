<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[深入理解虚拟机_1]]></title>
      <url>http://yoursite.com/2016/10/22/Jvm_1_%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
      <content type="html"><![CDATA[<p>了解和思考Java技术体系中这些技术特性是如何实现的，认识这些技术运作的本质，是自己思考“程序这样写好比好”的基础和前提。当我们在使用一种技术时，如果不在依赖于书本和他人就能得到这些问题的答案，那才算上升到了“不惑”的境界。</p>
<h1 id="Java内存区域与内存溢出异常"><a href="#Java内存区域与内存溢出异常" class="headerlink" title="Java内存区域与内存溢出异常"></a>Java内存区域与内存溢出异常</h1><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><pre><code>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行字节码的行号指示器。

Java虚拟机的多线程是通过线程的轮流切换并分配处理器执行时间的方式来实现的，因此为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

**此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。**
</code></pre><a id="more"></a>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><pre><code>与程序计数器一样，Java虚拟机栈也是线程私有的。它的生命周期与线程相同。

虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型）和returnAddress（指向了一条字节码指令地址）。

其中64位长度的long和double类型的数据会占用2个局部变量的空间，其余的数据类型只占用一个。

**局部变量表所需的内存空间在编译期间完成分配**，当进入一个方法时，**这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。**

在Java虚拟机规范中，对这个区域规定了两种异常情况：如果线程请求的深度大于虚拟机所允许的深度，将跑出StackOverflowError异常；如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常
</code></pre><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><pre><code>本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈微虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。

与虚拟机栈一样，本地方法栈区域也会跑出StackOverflowError和OutMemoryError异常。
</code></pre><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><pre><code>Java堆是被所有内存共享的一块区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。

Java堆是垃圾收集器管理的主要区域，因此很多时候也被称作“GC堆”。

根据Java虚拟机规范的规定，Java对可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存完成实例的分配，并且堆也无法在扩展时，将会跑出OutOfMemoryError异常。
</code></pre><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><pre><code>方法去与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码数据。

根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。
</code></pre><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><pre><code>运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号应用，这部分内容将在类加载后进入方法区的运行时常量池存放。
</code></pre><h2 id="虚拟机对象探秘"><a href="#虚拟机对象探秘" class="headerlink" title="虚拟机对象探秘"></a>虚拟机对象探秘</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><pre><code>虚拟机遇到一条new指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须执行相应的类加载过程。

在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成之后便可以完全确定（参考Java虚拟机栈）。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来（分配方式有指针碰撞和空闲列表）。

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型对应的零值。

接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄信息。这些信息存放在对象的对象头之中。

在上面的工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象的创建才刚刚开始————&lt;init&gt;方法还没有执行，所有的字段都还为零。所以一般来说（由字节码中是否跟随invokespecial指令决定），执行new指令之后会接着执行&lt;init&gt;方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。
</code></pre><h3 id="对象的内存区域"><a href="#对象的内存区域" class="headerlink" title="对象的内存区域"></a>对象的内存区域</h3><pre><code>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域，对象头，实例数据和对齐填充。

HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果一个对象是Java数组，那在对象头中还必须有一块用于记录数组长度的数据。

接下来的实例数据部分是对象真正存储的信息，也是在程序代码中所定义的各种类型的字段内容。

第三部分对齐填充并不是必然存在的，也没有特别含义，他仅仅起着占位的作用。由于HotSpot VM 的自动内存管理系统要求对象的起始地址必须是8字节的整数倍，对象头部分正好是8字节的倍数（1倍或2倍），因此，当对象实例数据部分没有对齐是，局需要通过对齐填充来补全。
</code></pre><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><pre><code>建立对象是为了适用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象，由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位，访问堆中具体对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有**使用句柄**和**直接指针**两种。
</code></pre><ul>
<li>如果使用句柄访问的话，那么在Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</li>
<li><p>如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。</p>
<p> 这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的示例数据指针，而reference本身不需要修改。</p>
<p> 使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销。由于对象访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。</p>
<p> 就HotSpot而言，它是使用第二种方式进行对象访问的。</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux下scp命令跳过登陆验证]]></title>
      <url>http://yoursite.com/2016/10/20/Linux%E4%B8%8Bscp%E5%91%BD%E4%BB%A4%E8%B7%B3%E8%BF%87%E7%99%BB%E9%99%86%E9%AA%8C%E8%AF%81/</url>
      <content type="html"><![CDATA[<h1 id="Linux下执行scp命令时跳过登陆验证"><a href="#Linux下执行scp命令时跳过登陆验证" class="headerlink" title="Linux下执行scp命令时跳过登陆验证"></a>Linux下执行scp命令时跳过登陆验证</h1><h2 id="生成安全信任关系证书"><a href="#生成安全信任关系证书" class="headerlink" title="生成安全信任关系证书"></a>生成安全信任关系证书</h2><p>1.在要执行scp命令的机器上 root 用户执行 <code>ssh-keygen</code> 命令，生成建立安全信任关系的证书。<br>[root@Client root]# ssh-keygen<br>Generating public/private rsa key pair.<br>Enter file in which to save the key (/root/.ssh/id_rsa):<br>Enter passphrase (empty for no passphrase):            &lt;– 直接输入回车<br>Enter same passphrase again:                           &lt;– 直接输入回车<br>Your identification has been saved in /root/.ssh/id_rsa.<br>Your public key has been saved in /root/.ssh/id_rsa.pub.<br>The key fingerprint is:<br>49:9c:8a:8f:bc:19:5e:8c:c0:10:d3:15:60:a3:32:1c root@Client<br>[root@Client root]#<br><a id="more"></a></p>
<p>注意：在程序提示输入passphrase时直接输入回车，表示无证书密码。<br>上述命令将生成私钥证书id_rsa和公钥证书id_rsa.pub，存放在用户家目录的.ssh子目录中。</p>
<h2 id="复制公钥证书"><a href="#复制公钥证书" class="headerlink" title="复制公钥证书"></a>复制公钥证书</h2><p>将公钥证书id_rsa.pub复制到机器Server的root家目录的.ssh子目录中（无此目录需要创建），同时将文件名更换为authorized_keys。</p>
<p>[root@Client root]# scp -p .ssh/id_rsa.pub root@192.168.3.206:/root/.ssh/authorized_keys<br>root@192.168.3.206’s password:          &lt;– 输入机器Server的root用户密码<br>id_rsa.pub           100% |<strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong>|   218       00:00<br>[root@Client root]#</p>
<h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><p>执行 ssh-copy-id root@10.10.60.119</p>
<p>如果不成功<br>修改./ssh 文件夹的权限为700<br>修改authorized_keys 文件的权限为600</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://yoursite.com/2016/10/19/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.<br><a id="more"></a></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring MVC]]></title>
      <url>http://yoursite.com/2016/08/09/Spring%20MVC/</url>
      <content type="html"><![CDATA[<h1 id="Spring-MVC-请求"><a href="#Spring-MVC-请求" class="headerlink" title="Spring MVC 请求"></a>Spring MVC 请求</h1><p>请求的第一站是Spring 的 DispatcherServlet。</p>
<p>DispatcherServlet 的任务是将请求发送给Spring MVC控制器（controller），DispatcherServlet 根据处理器映射来决定将请求发送到哪里。</p>
<p>到了控制器，请求会卸下负载（用户提交的信息），控制器开始处理请求。</p>
<p>控制器在完成逻辑处理之后，通常会产生一些信息，信息需要发送给一个视图（通常是JSP），用来展示给用户。<br><a id="more"></a></p>
<p>控制器做的最后一件事情就是将模型数据打包，并标示出用于渲染输出的视图名，接下来控制器会将请求连同模型和视图名发送回 DispatcherServlet。</p>
<p>DispatcherServlet 将使用视图解析器将逻辑视图名匹配为一个特定的视图实现。</p>
<p>最后一站是视图的实现，它将模型数据交付给视图进行渲染输出。</p>
<h1 id="搭建Spring-MVC"><a href="#搭建Spring-MVC" class="headerlink" title="搭建Spring MVC"></a>搭建Spring MVC</h1><p>DispatcherServlet 是Spring MVC的核心，他负责将请求路由到其他的组件当中。</p>
<h2 id="使用java-配置-DispatcherServlet（仅适用于Servlet3-0及以上的环境中）"><a href="#使用java-配置-DispatcherServlet（仅适用于Servlet3-0及以上的环境中）" class="headerlink" title="使用java 配置 DispatcherServlet（仅适用于Servlet3.0及以上的环境中）"></a>使用java 配置 DispatcherServlet（仅适用于Servlet3.0及以上的环境中）</h2><p>第一步：将 DispatcherServlet 配置在 Servlet容器中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;</div><div class="line"></div><div class="line">public class SpittrWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected Class&lt;?&gt;[] getRootConfigClasses() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return new Class&lt;?&gt;[]&#123; RootConfig.class&#125;;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected Class&lt;?&gt;[] getServletConfigClasses() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return new Class&lt;?&gt;[]&#123; WebConfig.class&#125;;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected String[] getServletMappings() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return new String[]&#123;&quot;/&quot;,&quot;&quot;&#125;;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码究竟是如何工作的呢？</p>
<blockquote>
<p> 在Servlet 3.0环境中，容器会在类路径下查找实现了 javax.servlet.ServletContainerInitializer 接口的类，如果能发现，就会用它来配置Servlet 容器</p>
<p> Spring 提供了这个接口的实现，名为 SpringServletContainerInitializer ，这个了会反过来查找实现了 WebApplicationInitializer 的类并将配置任务交给它们来完成。</p>
<p> 上述代码中继承的类就是在Spring 3.2 中引入的一个 WebApplicationInitializer 的基础实现。</p>
<p> 因此当部署到Servlet 3.0 容器中的时候，容器就会自动发现它并用它来配置Servlet上下文。</p>
</blockquote>
<p>第二步：启用Spring MVC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">import org.springframework.context.annotation.Bean;</div><div class="line">import org.springframework.context.annotation.ComponentScan;</div><div class="line">import org.springframework.context.annotation.Configuration;</div><div class="line">import org.springframework.web.servlet.ViewResolver;</div><div class="line">import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;</div><div class="line">import org.springframework.web.servlet.config.annotation.EnableWebMvc;</div><div class="line">import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</div><div class="line">import org.springframework.web.servlet.view.InternalResourceViewResolver;</div><div class="line"></div><div class="line">@Configuration</div><div class="line">@EnableWebMvc     //启用Spring MVC</div><div class="line">@ComponentScan(&quot;spittr.web&quot;) //启用组件扫描</div><div class="line">public class WebConfig extends WebMvcConfigurerAdapter&#123;</div><div class="line"></div><div class="line">	@Bean    //配置JSP视图解析器</div><div class="line">	public ViewResolver viewResolver()&#123;</div><div class="line">		InternalResourceViewResolver resolver = new InternalResourceViewResolver();</div><div class="line">		resolver.setPrefix(&quot;/WEB-INF/views/&quot;);</div><div class="line">		resolver.setSuffix(&quot;.jsp&quot;);</div><div class="line">		resolver.setExposeContextBeansAsAttributes(true);</div><div class="line">		return resolver;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override   //配置静态资源处理</div><div class="line">	public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		configurer.enable();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>第三步：配置RootConfig </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import org.springframework.context.annotation.ComponentScan;</div><div class="line">import org.springframework.context.annotation.ComponentScan.Filter;</div><div class="line">import org.springframework.web.servlet.config.annotation.EnableWebMvc;</div><div class="line">import org.springframework.context.annotation.Configuration;</div><div class="line">import org.springframework.context.annotation.FilterType;</div><div class="line"></div><div class="line">@Configuration</div><div class="line">@ComponentScan(basePackages = &#123; &quot;spittr&quot; &#125;, excludeFilters = &#123;</div><div class="line">		@Filter(type = FilterType.ANNOTATION, value = EnableWebMvc.class) &#125;)</div><div class="line">public class RootConfig &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过以上三步，我们的Spring MVC就已经初步搭建完成了。</p>
<p><strong>值得注意的是，如果在第一步配置中，getServletMappings 方法中只映射了 <code>/</code>,当你在你的controller中也只映射了斜线的话，这并不能拦截根路径的请求，他会默认跳转到webRoot目录下的index.jsp,除非删除这个index.jsp或者在 getServletMappings 方法中加上多空字符串的映射。</strong></p>
<h1 id="接受请求的输入"><a href="#接受请求的输入" class="headerlink" title="接受请求的输入"></a>接受请求的输入</h1><p>Spring MVC 中允许以多种方式将客户端中的数据传送到控制器的处理器方法中，包括：<br>1.查询参数<br>2.表单参数<br>3.路径变量</p>
<blockquote>
<p>针对查询参数，可以使用 <code>RequestParam</code> 注解来接收，不传参数时可以通过 <code>defaultValue</code> 指定默认值。</p>
</blockquote>
<p>eg: </p>
<p><code>public void getSpittle(@RequestParam(&quot;max&quot;) long max)</code></p>
<p><code>public void getSpittle(@RequestParam(value=&quot;max&quot;,defaultValue=20) long max)</code></p>
<blockquote>
<p>针对路径变量，可以使用占位符 <code>{}</code>,占位符部分可以是任意值。</p>
</blockquote>
<p>eg:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@RequestMapping(value=&quot;/&#123;spittleId&#125;&quot;)</div><div class="line">public void getSpittle(@pathVariable（&quot;spittleId&quot;） long spittleId)</div></pre></td></tr></table></figure>
<p><code>@pathVariable</code> 注解表示不管占位符部分的值是什么，都会传递到处理器方法的 <code>spittleId</code> 参数中，如对“spittles/12345”发送get请求，那么spittleId 的值为 12345.</p>
<p>如果方法的参数名称和占位符的名称相同，可以去掉<code>@pathVariable</code> 中的value 属性。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring4(1) 装配Bean]]></title>
      <url>http://yoursite.com/2016/07/15/Spring4-1/</url>
      <content type="html"><![CDATA[<h1 id="自动化装配Bean"><a href="#自动化装配Bean" class="headerlink" title="自动化装配Bean"></a>自动化装配Bean</h1><h2 id="创建可被发现的bean"><a href="#创建可被发现的bean" class="headerlink" title="创建可被发现的bean"></a>创建可被发现的bean</h2><h3 id="java中进行配置"><a href="#java中进行配置" class="headerlink" title="java中进行配置"></a>java中进行配置</h3><ul>
<li>在需要被自动化装配的类上加上 <code>@Component</code> 注解，该注解表明该类会作为组件类，并告知spring要为这个类创建bean。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package com.gdn.demo2;</div><div class="line"></div><div class="line">import org.springframework.stereotype.Component;</div><div class="line"></div><div class="line">@Component</div><div class="line">public class Man implements Person &#123;</div><div class="line">	private String name;</div><div class="line">	</div><div class="line">	public Man(String name) &#123;</div><div class="line">		super();</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setName(String name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>那么我们如何为组件扫描的bean命名呢？一共有两种方案来实现。</p>
<p>第一种方案是还是采用 <code>@Component</code> 注解： <code>@Component（&quot;man&quot;）</code></p>
<p>第二种方案则不再采用 <code>@Component</code> 注解，而是使用Java依赖注入规范中所提供的 <code>@Named</code> 注解来为bean设置ID：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package com.gdn.demo2;</div><div class="line"></div><div class="line">import javax.inject.Named;</div><div class="line"></div><div class="line">@Named(&quot;man&quot;)</div><div class="line">public class Man implements Person &#123;</div><div class="line">	private String name;</div><div class="line">	</div><div class="line">	public Man(String name) &#123;</div><div class="line">		super();</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setName(String name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>由于组件扫面默认是不启用的，我们还需要显示的配置一下spring，让他去寻找带有 <code>@Component</code> 注解的类。配置如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">package com.gdn.demo2;</div><div class="line"></div><div class="line">import org.springframework.context.annotation.ComponentScan;</div><div class="line">import org.springframework.context.annotation.Configuration;</div><div class="line"></div><div class="line">@Configuration</div><div class="line">@ComponentScan</div><div class="line">public class BedConfig &#123;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上面你的配置所示， <code>@ComponentScan</code> 默认会扫描与配置类同包以及子包下的类。遇到带有 <code>@Component</code> 注解的类就会自动为其创建一个bean。</p>
<p>那么我们如何制定不同的基础包呢？</p>
<p>只需在 <code>@ComponentScan</code> 的value属性中指明包的名称即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Configuration</div><div class="line">@ComponentScan(&quot;com.gdn.demo2&quot;)</div><div class="line">public class BedConfig &#123;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果想要更加清晰的表明所设置的包是基础包，可以通过 basePackages 属性进行配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Configuration</div><div class="line">@ComponentScan(basePackages=&quot;com.gdn.demo2&quot;)</div><div class="line">public class BedConfig &#123;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除此之外，我们还可以设置多个基础包，只需将 basePackages 的属性值设置成一个数组即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Configuration</div><div class="line">@ComponentScan(basePackages=&#123;&quot;com.gdn.demo1&quot;,&quot;com.gdn.demo2&quot;&#125;)</div><div class="line">public class BedConfig &#123;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的配置中不难发现，所有设置的基础包都是以String类型表示的，这种方法是类型不安全的，当进行代码重构时，可能会引发错误。</p>
<p>所以除了上述方法之外， <code>@ComponentScan</code>还提供了另一种方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Configuration</div><div class="line">@ComponentScan(basePackageClasses=&#123;demo1.class,demo2.class&#125;)</div><div class="line">public class BedConfig &#123;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="通过xml进行配置"><a href="#通过xml进行配置" class="headerlink" title="通过xml进行配置"></a>通过xml进行配置</h3><p>如果想要通过xml配置的方式启用组件扫描的话，需要引入Spring context命名空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div class="line">	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">	xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</div><div class="line">	xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</div><div class="line">	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd&quot;&gt;</div><div class="line"></div><div class="line">	&lt;context:component-scan base-package=&quot;com.gdn.demo2&quot;&gt;&lt;/context:component-scan&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>通过上面的配置，我们已经定义完成了可以被Spring发现的bean，接下来要做的工作就是进行自动装配。</p>
<p>为了声明要进行自动装配，可以借助Spring的 <code>@Autowired</code> 注解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package com.gdn.demo2;</div><div class="line"></div><div class="line">import org.springframework.beans.factory.annotation.Autowired;</div><div class="line">import org.springframework.stereotype.Component;</div><div class="line"></div><div class="line">@Component</div><div class="line">public class Bed &#123;</div><div class="line"></div><div class="line">	private Man man;</div><div class="line">	private Women women;</div><div class="line"></div><div class="line">	@Autowired(required = false)</div><div class="line">	public Bed(Man man,Women women)&#123;</div><div class="line">		this.man = man;</div><div class="line">		this.women = women;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void MakeBaby()&#123;</div><div class="line">		System.out.println(man.getName() + &quot;和&quot; + women.getName() + &quot;生了一个小baby！&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码中，在bed的构造器上添加了 <code>@Autowired</code> 注解。这表明当Spring创建Bed bean时，会通过这个构造器来实例化并会传入Man 和 Women 类型的bean。</p>
<p><code>@Autowired</code> 注解也可以用在属性的Setter方法上。</p>
<p>Setter方法并没有什么特殊之处，所以 <code>@Autowired</code> 注解可以用在类的任何方法上，不管构造器、Setter方法还是其他的方法，Spring都会尝试满足方法参数上所声明的依赖。</p>
<p><code>@Autowired(required = false)</code> 注解的require属性值如果设置为false，那么当spring没有找的匹配的bean时，spring会让这个bean处于未装配的状态，否则则会抛出异常。</p>
<h1 id="显示装配Bean"><a href="#显示装配Bean" class="headerlink" title="显示装配Bean"></a>显示装配Bean</h1><p>除了自动装配之外，我们还可以显示的装配我们需要的Bean。</p>
<h2 id="通过java配置进行显示装配"><a href="#通过java配置进行显示装配" class="headerlink" title="通过java配置进行显示装配"></a>通过java配置进行显示装配</h2><h3 id="声明（创建）Bean"><a href="#声明（创建）Bean" class="headerlink" title="声明（创建）Bean"></a>声明（创建）Bean</h3><p>创建JavaConfig类的关键在于为其添加 <code>Configuration</code> 注解。</p>
<p>要在JavaConfig中声明Bean，需要编写一个方法，这个方法创建所需类型的实例，然后给这个方法添加 <code>@Bean</code> 注解。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">package com.gdn.demo2;</div><div class="line"></div><div class="line">import org.springframework.context.annotation.Bean;</div><div class="line">import org.springframework.context.annotation.Configuration;</div><div class="line"></div><div class="line">@Configuration</div><div class="line">public class BedConfig &#123;</div><div class="line">	</div><div class="line">	@Bean(name=&quot;man&quot;)  //此处不指定name属性的值，则bean的名称和方法名相同。此处为man</div><div class="line">	public Man man()&#123;</div><div class="line">		return new Man(&quot;xiaomng&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Bean</div><div class="line">	public Women women()&#123;</div><div class="line">		return new Women(&quot;baby&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Bean</div><div class="line">	public Bed bed()&#123;</div><div class="line">		return new Bed(man(), women());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="实现注入（装配）"><a href="#实现注入（装配）" class="headerlink" title="实现注入（装配）"></a>实现注入（装配）</h3><p>在JavaConfig中装配bean最简单的方法就是引用创建的bean的方法。如上面声明Bean的JavaConfig中的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Bean</div><div class="line">public Bed bed()&#123;</div><div class="line">	return new Bed(man(), women());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在创建bed 的 bean时引用了man()和women()两个方法。</p>
<p>注：值得注意的是，虽然man 是调用man()得到的，但其实并非完全如此。因为man()上添加了 <code>@Bean</code> 注解，spring将会拦截所有对他的调用，并确保直接返回该方法所创建的bean，而不是每次都对其进行实际的调用。</p>
<p>比如在写一个anotherBed的方法，两次传入的bean（man和women）完全一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Bean</div><div class="line">public Bed bed()&#123;</div><div class="line">	return new Bed(man(), women());</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Bean</div><div class="line">public Bed anotherBed()&#123;</div><div class="line">	return new Bed(man(), women());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>所以说，默认情况下，spring中所有的bean都是单例的。</strong></p>
<p>除此之外，我们还有另外一种方式装配bean。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Bean</div><div class="line">public Bed bed(Man man，Women women)&#123;</div><div class="line">	return new Bed(man, women);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，bed() 方法请求了一个Man 和一个 Women 作为参数，当Spring调用bed()创建bed bean的时候，就会自动转配一个Man 和 Women 到配置方法之中。</p>
<p>这种方法不需要明确的引用Man 或者 Women的@Bean 方法，而且不需要将Man 或者 Women的@Bean 方法声明到同一个配置类当中。</p>
<p><strong>所以说，通过第二种方式引用其他的 bean 通常是最佳的选择</strong></p>
<h2 id="通过XML配置进行显示装配"><a href="#通过XML配置进行显示装配" class="headerlink" title="通过XML配置进行显示装配"></a>通过XML配置进行显示装配</h2><h3 id="声明（创建）Bean-1"><a href="#声明（创建）Bean-1" class="headerlink" title="声明（创建）Bean"></a>声明（创建）Bean</h3><p>要在基于XML 的Spring 配置中声明一个bean，我们需要使用一个元素：<bean>。在这里<bean> 元素类似于JavaConfig 中的 <code>@Bean</code> 注解。</bean></bean></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div class="line">	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">	xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</div><div class="line">	xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</div><div class="line">	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd&quot;&gt;</div><div class="line"></div><div class="line">	&lt;bean class=&quot;com.gdn.demo2.Bed&quot; id=&quot;bed&quot;&gt;&lt;/bean&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>注：如果上述配置中不指定id属性，bean将根据全限定类名来进行命名，本例中bean的ID 将会是 <code>com.gdn.demo2.Bed#0</code> ,其中#0是一个计数方式，如果同时声明了另外一个Bed，并且也没有指定id,则其自动得到的id将会是 <code>com.gdn.demo2.Bed#1</code>。</p>
<h3 id="实现注入（装配）-1"><a href="#实现注入（装配）-1" class="headerlink" title="实现注入（装配）"></a>实现注入（装配）</h3><h4 id="注入引用"><a href="#注入引用" class="headerlink" title="注入引用"></a>注入引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div class="line">	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">	xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</div><div class="line">	xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</div><div class="line">	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd&quot;&gt;</div><div class="line"></div><div class="line">	&lt;bean class=&quot;com.gdn.demo2.Man&quot; id=&quot;man&quot;&gt;&lt;/bean&gt;</div><div class="line">	&lt;bean class=&quot;com.gdn.demo2.Women&quot; id=&quot;women&quot;&gt;&lt;/bean&gt;</div><div class="line">	&lt;bean class=&quot;com.gdn.demo2.Bed&quot; id=&quot;bed&quot;&gt;</div><div class="line">		&lt;constructor-arg ref=&quot;man&quot; /&gt;</div><div class="line">		&lt;constructor-arg ref=&quot;women&quot; /&gt;</div><div class="line">	&lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>除了上述配置之外，我们还可以采用Spring的c-命名空间（Spring3.0中引入的）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div class="line">	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">	xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</div><div class="line">	xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</div><div class="line">	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd&quot;</div><div class="line"></div><div class="line">	&lt;bean class=&quot;com.gdn.demo2.Man&quot; id=&quot;man&quot;&gt;&lt;/bean&gt;</div><div class="line">	&lt;bean class=&quot;com.gdn.demo2.Women&quot; id=&quot;women&quot;&gt;&lt;/bean&gt;</div><div class="line"></div><div class="line">	&lt;bean class=&quot;com.gdn.demo2.Bed&quot; id=&quot;bed&quot; c:man-ref=&quot;man&quot; c:women-ref=&quot;women&quot;/&gt;</div><div class="line">		</div><div class="line"></div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>上述配置中，”c:” 是c-命名空间前缀，”man”是构造器参数名，”ref” 是注入bean的引用，”man”是要注入bean的id。</p>
<p>同样运用c-命名空间，但是我们可以换另一种写法，这种写法不需要构造器的参数名称,而是将参数的名称换成参数的索引，由于XML中不允许数字作为属性的第一个字符，所以必须添加一个下划线作为前缀。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;com.gdn.demo2.Bed&quot; id=&quot;bed&quot; c:_0-ref=&quot;man&quot; c:_1-ref=&quot;women&quot;/&gt;</div></pre></td></tr></table></figure>
<p>如果只有一个构造参数，我们可以不用去表示参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;com.gdn.demo2.Bed&quot; id=&quot;bed&quot; c:_-ref=&quot;man&quot;/&gt;</div></pre></td></tr></table></figure>
<h4 id="注入字面量"><a href="#注入字面量" class="headerlink" title="注入字面量"></a>注入字面量</h4><p>此处不在详细介绍，只列出简单写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;com.gdn.demo2.Say&quot; id=&quot;say&quot;&gt;</div><div class="line">	&lt;constructor-arg value=&quot;hello word!&quot; /&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;com.gdn.demo2.Say&quot; id=&quot;say&quot; c:_title=&quot;hello word!&quot;/&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;com.gdn.demo2.Say&quot; id=&quot;say&quot; c:_0=&quot;hello word!&quot;/&gt;</div></pre></td></tr></table></figure>
<h3 id="装配集合"><a href="#装配集合" class="headerlink" title="装配集合"></a>装配集合</h3><p>在装配集合时，c-命名空间是无法做到的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;com.gdn.demo2.Say&quot; id=&quot;say&quot;&gt;</div><div class="line">	&lt;constructor-arg&gt;&lt;null/&gt;&lt;/constructor-arg&gt;  //将集合设置为null。</div><div class="line">	&lt;constructor-arg&gt;</div><div class="line">		&lt;list&gt;</div><div class="line">	`		&lt;value&gt;hello&lt;value&gt;</div><div class="line">			&lt;value&gt;word&lt;value&gt;</div><div class="line">			&lt;value&gt;!&lt;value&gt;</div><div class="line">		&lt;/list&gt;</div><div class="line">	&lt;/constructor-arg&gt;</div><div class="line"></div><div class="line">	&lt;constructor-arg&gt;</div><div class="line">		&lt;list&gt;</div><div class="line">	`		&lt;ref bean=&quot;man&quot;&gt;</div><div class="line">			&lt;ref bean=&quot;women&quot;&gt;</div><div class="line">		&lt;/list&gt;</div><div class="line">	&lt;/constructor-arg&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>当构造器的参数是java.util.List时，使用<list>集合是合理的。尽管如此，我们可以按照同样的方式是用<set>元素：</set></list></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;com.gdn.demo2.Say&quot; id=&quot;say&quot;&gt;</div><div class="line">	&lt;constructor-arg&gt;&lt;null/&gt;&lt;/constructor-arg&gt;  //将集合设置为null。</div><div class="line">	&lt;constructor-arg&gt;</div><div class="line">		&lt;set&gt;</div><div class="line">	`		&lt;value&gt;hello&lt;value&gt;</div><div class="line">			&lt;value&gt;word&lt;value&gt;</div><div class="line">			&lt;value&gt;!&lt;value&gt;</div><div class="line">		&lt;/set&gt;</div><div class="line">	&lt;/constructor-arg&gt;</div><div class="line"></div><div class="line">	&lt;constructor-arg&gt;</div><div class="line">		&lt;set&gt;</div><div class="line">	`		&lt;ref bean=&quot;man&quot;&gt;</div><div class="line">			&lt;ref bean=&quot;women&quot;&gt;</div><div class="line">		&lt;/set&gt;</div><div class="line">	&lt;/constructor-arg&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p><strong><set> 和 <list> 区别不大，其中最重要的不同在于当Spring创建要装配的集合时，所创建的是java.util.List 还是 java.util.Set ，如果是Set的话，则所有重复的值都会被忽略掉，存放顺序也不会得到保证。</list></set></strong></p>
<p><strong>不论在那种情况<set> 和 <list> 都可以装配List Set 甚至数组</list></set></strong></p>
<h3 id="设置属性"><a href="#设置属性" class="headerlink" title="设置属性"></a>设置属性</h3><p>在上述的方法中，全部是采用构造器注入的方式实现bean的装配。下面将介绍如何使用Spring XML 实现属性注入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">package com.gdn.demo2;</div><div class="line"></div><div class="line">import org.springframework.beans.factory.annotation.Autowired;</div><div class="line">import org.springframework.stereotype.Component;</div><div class="line"></div><div class="line">public class Bed &#123;</div><div class="line"></div><div class="line">	private Man man;</div><div class="line">	private Women women;</div><div class="line">	</div><div class="line">	@Autowired</div><div class="line">	public void setMan(Man man) &#123;</div><div class="line">		this.man = man;</div><div class="line">	&#125;</div><div class="line">	@Autowired</div><div class="line">	public void setWomen(Women women) &#123;</div><div class="line">		this.women = women;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void MakeBaby()&#123;</div><div class="line">		System.out.println(man.getName() + &quot;和&quot; + women.getName() + &quot;生了一个小baby！&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据上述代码，我们可以采用如下的配置方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;com.gdn.demo2.Man&quot; id=&quot;man&quot;&gt;&lt;/bean&gt;</div><div class="line">&lt;bean class=&quot;com.gdn.demo2.Women&quot; id=&quot;women&quot;&gt;&lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;bean class=&quot;com.gdn.demo2.Bed&quot; id=&quot;bed&quot;&gt;</div><div class="line">	&lt;property name=&quot;man&quot; ref=&quot;man&quot; /&gt;</div><div class="line">	&lt;property name=&quot;women&quot; ref=&quot;women&quot; /&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>除了使用<property> 元素，我们也可以使用p-命名空间：</property></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;com.gdn.demo2.Man&quot; id=&quot;man&quot;&gt;&lt;/bean&gt;</div><div class="line">&lt;bean class=&quot;com.gdn.demo2.Women&quot; id=&quot;women&quot;&gt;&lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;bean class=&quot;com.gdn.demo2.Bed&quot; id=&quot;bed&quot;&gt;</div><div class="line">	&lt;p:man-ref=&quot;man&quot; /&gt;</div><div class="line">	&lt;p:women-ref=&quot;women&quot; /&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>使用<property> 元素 或者p-命名空间 注入字面量和集合</property></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;com.gdn.demo2.Say&quot; id=&quot;say&quot;&gt;</div><div class="line">	&lt;property name=&quot;title&quot; value=&quot;hello word!&quot; /&gt;</div><div class="line">	&lt;p:title=&quot;hello word!&quot; /&gt;</div><div class="line">	&lt;property name=&quot;titles&quot;&gt;</div><div class="line">		&lt;list&gt;</div><div class="line">			&lt;value&gt;hello&lt;/value&gt;</div><div class="line">			&lt;value&gt;word&lt;/value&gt;</div><div class="line">			&lt;value&gt;!&lt;/value&gt;</div><div class="line">		&lt;/list&gt;</div><div class="line">	&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>那么针对构造器注入和属性注入应该选择哪一个呢？</p>
<p><strong>作为一个通用的规则，对于强依赖使用构造器注入，而对可选性的依赖使用属性注入。</strong></p>
<h1 id="混合配置"><a href="#混合配置" class="headerlink" title="混合配置"></a>混合配置</h1><h2 id="JavaConfig中合并"><a href="#JavaConfig中合并" class="headerlink" title="JavaConfig中合并"></a>JavaConfig中合并</h2><h3 id="JavaConfig中引入JavaConfig"><a href="#JavaConfig中引入JavaConfig" class="headerlink" title="JavaConfig中引入JavaConfig"></a>JavaConfig中引入JavaConfig</h3><p>实现在JavaConfig中引入JavaConfig 使用 <code>@Import</code>  注解：</p>
<p><code>@Import(yourConfig.class)</code><br><code>@Import({yourConfig1.class,yourConfig2.class})</code></p>
<h3 id="JavaConfig中引入XML"><a href="#JavaConfig中引入XML" class="headerlink" title="JavaConfig中引入XML"></a>JavaConfig中引入XML</h3><p>实现在JavaConfig中引入JavaConfig 使用 <code>@ImportResource</code>  注解：</p>
<p><code>@ImportResource(classpath:yourConfig.xml)</code></p>
<p>注：yourConfig.xml 需放在根类路径下。</p>
<h2 id="XML中合并"><a href="#XML中合并" class="headerlink" title="XML中合并"></a>XML中合并</h2><h3 id="XML中引入XML"><a href="#XML中引入XML" class="headerlink" title="XML中引入XML"></a>XML中引入XML</h3><p>实现在XML中引入XML 使用 <code>&lt;import&gt;</code> 元素：</p>
<p><code>&lt;import resoune=&quot;yourConfig.xml&quot;&gt;</code></p>
<h3 id="XML中引入JavaConfig"><a href="#XML中引入JavaConfig" class="headerlink" title="XML中引入JavaConfig"></a>XML中引入JavaConfig</h3><p>实现在XML中引入JavaConfig 使用 <code>&lt;bean&gt;</code> 元素：</p>
<p><code>&lt;bean class=&quot;yourConfig&quot;&gt;</code></p>
<p><strong>在合并这些配置文件中，我们可以创建一个更高层次的配置文件，这个文件中不声明任何的bean，只是负责将多个配置组合起来。</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo环境搭建(windows)]]></title>
      <url>http://yoursite.com/2016/07/13/Hexo/</url>
      <content type="html"><![CDATA[<p>这是一篇有关如何使用github Pages和Hexo搭建自己独立博客的详尽教程，里面介绍了如何使用和配置Hexo框架，如何将Hexo部署到自己的github项目中，域名注册，以及域名的绑定等功能。<br><a id="more"></a></p>
<h1 id="依赖环境安装"><a href="#依赖环境安装" class="headerlink" title="依赖环境安装"></a>依赖环境安装</h1><h2 id="Node-js的安装"><a href="#Node-js的安装" class="headerlink" title="Node.js的安装"></a>Node.js的安装</h2><p><a href="https://nodejs.org/en/" target="_blank" rel="external">下载Node.js</a></p>
<img src="/2016/07/13/Hexo/1.png" alt="1.png" title="">
<p>本文下载的版本是当时的最新版6.3.0。下载完成后安装即可。</p>
<p>查看是否安装成功:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node -v</div></pre></td></tr></table></figure>
<p>出现如下图所示内容代表Node.js安装成功</p>
<img src="/2016/07/13/Hexo/2.png" alt="2.png" title="">
<h2 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h2><p>请自行谷歌。</p>
<p>查看是否安装成功:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git --version</div></pre></td></tr></table></figure>
<p>出现如下图所示内容代表Git安装成功</p>
<img src="/2016/07/13/Hexo/3.png" alt="3.png" title="">
<h2 id="Hexo的安装"><a href="#Hexo的安装" class="headerlink" title="Hexo的安装"></a>Hexo的安装</h2><p>以管理员身份运行cmd执行如下命令</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g hexo-cli</div></pre></td></tr></table></figure>
<p>最后会出现大概这么一条信息 <img src="/2016/07/13/Hexo/4.png" alt="4.png" title=""></p>
<p>说明hexo 已经安装成功了。</p>
<h3 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h3><p>接下来，我们选择一个硬盘目录作为存放我们博客的路径，例如我手动在E盘目录下建了一个blog的文件夹，然<br>后执行以下命令完成hexo 的初始化。</p>
<blockquote>
<p>注：如不指定 e:\blog 则在当前文件夹完成hexo的初始化</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo init e:\blog</div></pre></td></tr></table></figure>
<p>进入该目录，执行如下命令，系统会可以根据package.json文件中dependencies的配置安装所有依赖包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install</div></pre></td></tr></table></figure></p>
<h3 id="生成部署文件"><a href="#生成部署文件" class="headerlink" title="生成部署文件"></a>生成部署文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo g</div></pre></td></tr></table></figure>
<h3 id="启动本地服务器"><a href="#启动本地服务器" class="headerlink" title="启动本地服务器"></a>启动本地服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo s</div></pre></td></tr></table></figure>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#生成静态文件，会在当前目录下生成一个新的叫做public的文件夹</div><div class="line">hexo generate (hexo g) </div><div class="line"></div><div class="line">#启动本地web服务，用于博客的预览</div><div class="line">hexo server (hexo s) </div><div class="line"></div><div class="line">#部署博客到远端服务器</div><div class="line">hexo deploy (hexo d)</div><div class="line"></div><div class="line">#新建文章</div><div class="line">hexo new fileName  </div><div class="line"></div><div class="line">#新建页面</div><div class="line">hexo new page</div></pre></td></tr></table></figure>
<p><a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="external">更多指令&gt;&gt;</a></p>
<h1 id="部署博客到github-Pages"><a href="#部署博客到github-Pages" class="headerlink" title="部署博客到github Pages"></a>部署博客到github Pages</h1><p>每个帐号只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。你可以通过<a href="http://username.github.io" target="_blank" rel="external">http://username.github.io</a> 来访问你的个人主页。</p>
<h2 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h2><p>上传文件需要配置ssh key，不然无法上传。 </p>
<p>首先先检查一下本地是否已经存在ssh key,在Git Bash输入以下指令（任意位置点击鼠标右键），检查是否已经存在了SSH keys。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -al ~/.ssh</div></pre></td></tr></table></figure>
<img src="/2016/07/13/Hexo/5.png" alt="5.png" title="">
<p>如上图所示，由于我已经配置过，所以存在红框内的三个文件，我们直接把这三个文件删掉即可。</p>
<p>删除完成后，设置name和email</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name xxx</div><div class="line">git config --global user.email xxx@xxx.com</div></pre></td></tr></table></figure>
<blockquote>
<p>注：需要注意的是这里的name是随意的，邮箱是你的联系邮箱，与github上的邮箱没有什么联系。</p>
</blockquote>
<h2 id="生成ssh-密钥"><a href="#生成ssh-密钥" class="headerlink" title="生成ssh 密钥"></a>生成ssh 密钥</h2><p>输入以下指令（邮箱就是你注册github时候的邮箱）后，回车：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C xxx@xxx.com</div></pre></td></tr></table></figure>
<p>一路按回车键即可，如果设置了密码请记住。 </p>
<p>这一步在~/.ssh/下生成了两个文件id_rsa 和 id_rsa.pub</p>
<h2 id="将秘钥拷贝至github"><a href="#将秘钥拷贝至github" class="headerlink" title="将秘钥拷贝至github"></a>将秘钥拷贝至github</h2><p>拷贝id_rsa.pub的内容拷贝至github上，如下图<br><img src="/2016/07/13/Hexo/6.png" alt="6.png" title=""><br><img src="/2016/07/13/Hexo/7.png" alt="7.png" title=""></p>
<h2 id="测试是否成功"><a href="#测试是否成功" class="headerlink" title="测试是否成功"></a>测试是否成功</h2><p>输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh git@github.com</div></pre></td></tr></table></figure>
<p>成功的话会显示以下的大致内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">The authenticity of host &apos;github.com (192.30.252.128)&apos; can&apos;t be established.</div><div class="line">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</div><div class="line">Are you sure you want to continue connecting (yes/no)? yes</div><div class="line">Warning: Permanently added &apos;github.com,192.30.252.128&apos; (RSA) to the list of known hosts.</div><div class="line">Hi git-xuhao! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</div><div class="line">Connection to github.com closed.</div></pre></td></tr></table></figure>
<h2 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h2><h3 id="配置-config-yml"><a href="#配置-config-yml" class="headerlink" title="配置_config.yml"></a>配置_config.yml</h3><p>编辑hexo初始化目录下的_config.yml，修改Deployment部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#Deployment</div><div class="line">##Docs: https://hexo.io/docs/deployment.html</div><div class="line">#ssh://git@github.com/gengdn/gengdn.github.io</div><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: ssh:</div><div class="line">  branch: master</div></pre></td></tr></table></figure>
<p>其中，repo是我们刚刚建立的远程仓库，换成你自己的仓库，同时因为刚才配置了SSH-Key，所以必须是SSH形式的URL。值得注意的是，每一个: 后面都必须有一个空格，否则会引起错误。</p>
<h3 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h3><p><code>npm install hexo-deployer-git --save</code></p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p><code>hexo deploy</code></p>
<p>现在我们可以通过访问 <a href="http://gengdn.github.io/" target="_blank" rel="external">http://gengdn.github.io/</a> 来访问我们自己的博客啦,可以看到我们的博客已成功搭建，接下来就是一些主题的优化和配置呢。</p>
<h1 id="添加搜索（Local-Search）"><a href="#添加搜索（Local-Search）" class="headerlink" title="添加搜索（Local Search）"></a>添加搜索（Local Search）</h1><h2 id="安装-hexo-generator-search"><a href="#安装-hexo-generator-search" class="headerlink" title="安装 hexo-generator-search"></a>安装 hexo-generator-search</h2><p>在站点的根目录下执行以下命令：</p>
<p><code>npm install hexo-generator-search --save</code></p>
<h2 id="编辑站点配置文件（根目录下的-config-yml）"><a href="#编辑站点配置文件（根目录下的-config-yml）" class="headerlink" title="编辑站点配置文件（根目录下的_config.yml）"></a>编辑站点配置文件（根目录下的_config.yml）</h2><p>新增以下内容到任意位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">search:</div><div class="line">  path: search.xml</div><div class="line">  field: post</div></pre></td></tr></table></figure>
<h1 id="功能点记录"><a href="#功能点记录" class="headerlink" title="功能点记录"></a>功能点记录</h1><h2 id="tags和categories-页面无法显示"><a href="#tags和categories-页面无法显示" class="headerlink" title="tags和categories 页面无法显示"></a>tags和categories 页面无法显示</h2><p>在hexo初始化的根目录下执行如下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo new page tags</div><div class="line">hexo new page categories</div></pre></td></tr></table></figure>
<p>执行完上述两条命令之后会在source文件下生成两个对应的文件夹，修改文件夹内的index.md文件，将如下内容拷贝纸对应的index.md即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: categories</div><div class="line">date: 2016-07-13 20:58:32</div><div class="line">type: &quot;categories&quot;</div><div class="line">comments: true</div><div class="line">---</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: tags</div><div class="line">date: 2016-07-13 20:58:07</div><div class="line">type: &quot;tags&quot;</div><div class="line">comments: true</div><div class="line">---</div></pre></td></tr></table></figure>
<h2 id="添加本地资源"><a href="#添加本地资源" class="headerlink" title="添加本地资源"></a>添加本地资源</h2><h3 id="资源文件夹"><a href="#资源文件夹" class="headerlink" title="资源文件夹"></a>资源文件夹</h3><p>Hexo提供了组织化的方式来管理资源,资源可以分布在各个文章上，通过将 config.yml文件中的 post_asset_folder 选项设为 true 来打开</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">post_asset_folder: true</div></pre></td></tr></table></figure>
<p>资源文件管理功能打开后，Hexo将会在每一次通过 hexo new title命令创建新文章时自动创建一个文件夹,这个资源文件夹与 markdown 文件同名。将所有与文章有关的资源放在这个关联文件夹中，可以通过相对路径来引用它们</p>
<h3 id="资源的引用"><a href="#资源的引用" class="headerlink" title="资源的引用"></a>资源的引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% asset_img slug [title] %&#125;</div><div class="line">&#123;% asset_link slug [title] %&#125;</div><div class="line">&#123;% asset_path slug %&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注：slug 替换为资源路径<br>[title] 替换为文字，可为空</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eg:  &#123;% asset_img 5.png  %&#125;</div></pre></td></tr></table></figure>
<h1 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h1><ul>
<li><a href="http://ms.csdn.net/geek/72697" target="_blank" rel="external">基于Hexo+GitHub Pages 免费搭建个人博客最强教程</a></li>
<li><a href="http://theme-next.iissnan.com/" target="_blank" rel="external">NexT主题</a></li>
<li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">Hexo文档</a></li>
</ul>
]]></content>
    </entry>
    
  
  
</search>
